#Global Hooks

$Simulation: [
	if Movements then
		Movements:OnSimulation()
	end
]

#End

#Conditional Hooks

$Application: FS2_Open

$On Game Init: [

	--Version 1.8, released on Auguest 21, 2022 by wookieejedi
	--Description: custom sexps and functions that allow for much easier ship movements and rotations
	--Usage: custom sexps are included and listed in FRED under the LUA-Movements tab
	
	Movements = {} --makes a global variable! This is the only global variable this script creates.

	function math.atan2safe(y, x)
			
		local ang 
		local pi = math.pi
		local pi2 = pi/2.0
		
		if x == 0 then 
		
			if y == 0 then
				ang = 0
			elseif y > 0 then
				ang = pi2
			else
				ang = -pi2
			end
			return ang
			
		end
		
		ang = math.atan(y/x)
		if x < 0 then
			ang = ang + pi
		end
		
		return ang
		
	end

	function Movements:Initiate()
		--remember that a ship not in mission will be nil in lua sexp if input parameter is type ship 
		self.Time_Previous_Check = 0
		self.G_Time_Check_Interval = 0.1
		self.Active_Rotations = {}
		self.Active_Rotations_Sum = 0
		self.Active_Ships_trk_Wpts = {}
		self.Active_Ships_trk_Wpts_Sum = 0
		self.Active_Wpts_trk_Objects = {}
		self.Active_Wpts_trk_Objects_Sum = 0
		self.is_enabled = true
		
		if ba.MultiplayerMode then
			self.is_enabled = false
		end

	end

	function Movements:Round(input_number, numDecimalPlaces) --if no number of decimals is specified then it defaults to 0

		local output
		input_number = tonumber(input_number)
		if numDecimalPlaces == nil then numDecimalPlaces = 0 end

		if numDecimalPlaces == 0 then
			output = math.floor(math.floor(input_number + 0.5))
		end

		if numDecimalPlaces > 0 then
			local mult = 10^numDecimalPlaces
			output = math.floor(input_number * mult + 0.5) / mult
		end

		return output

	end

	function Movements:Get_safe_number(num, iswholenumber, onlypositive, abovezero) --defaults are all true

		if type(num) ~= "number" then
			num = 0
		end
		
		--DO NOT use or true to set defaults since it make make it true even if setting it to false (ie false or true = true)
		
		if iswholenumber == nil then 
			iswholenumber = true
		end
		if onlypositive == nil then 
			onlypositive = true
		end
		if abovezero == nil then 
			abovezero = true
		end
		
		if iswholenumber then
			num = self:Round(num)
		end
		if onlypositive and num < 0 then
			num = 0
		end
		if abovezero and num <= 0 then
			num = 1
		end

		return num

	end

    function Movements:PBH_3x3(pbh) --input is radians
            
        local p, b, h = pbh.p, pbh.b, pbh.h
        
        local sinp = math.sin(p)
        local cosp = math.cos(p)
        local sinb = math.sin(b)
        local cosb = math.cos(b)
        local sinh_ = math.sin(h)
        local cosh_ = math.cos(h)
        local sbsh = sinb*sinh_
        local cbch = cosb*cosh_
        local cbsh = cosb*sinh_
        local sbch = sinb*cosh_

        local vals ={
            cbch + (sinp*sbsh), --1
            (sinp*cbsh) - sbch, --2
            sinh_*cosp, --3
            sinb*cosp, --4
            cosb*cosp, --5
            -sinp, --6
            sinp*sbch - cbsh,--7
            sbsh + (sinp*cbch), --8
            cosh_*cosp--9
        }
        
        for i,v in ipairs(vals) do
            vals[i] = self:Round(v,6)
        end

        local finalm = {{vals[1],vals[4],vals[7]},{vals[2],vals[5],vals[8]},{vals[3],vals[6],vals[9]}}
        
        return finalm 
        
    end

    function Movements:m3x3_to_PBH(m3x3) --gets PBH in radians

        local rvec = m3x3[1]
        local uvec = m3x3[2]
        local fvec = m3x3[3]

        local heading = math.atan2safe(fvec[1], fvec[3]) 

        local sinh = math.sin(heading)
        local cosh = math.cos(heading)
        local cosp

        if math.abs(sinh) > math.abs(cosh) then
            cosp = fvec[1] * sinh
        else
            cosp = fvec[3] * cosh
        end

        local fvec_xz_distance = math.sqrt( (fvec[1] * fvec[1]) + (fvec[3] * fvec[3]) ) --( fvec.xyz.x^2 + fvec.xyz.z^2 )^0.5

        local pitch = math.atan2safe(-fvec[2], fvec_xz_distance) --<gives correct pitch 

        local bank 

        if cosp == 0 then
            bank = 0
        else
            local sinb = rvec[2] / cosp
            local cosb = uvec[2] / cosp
            
            bank = math.atan2safe(sinb, cosb)
        end

        --ba.print("pitch: "..math.deg(pitch)..", bank:"..math.deg(bank)..", heading:"..math.deg(heading))
        return {p=pitch, b=bank, h=heading}
        
    end

	function Movements:PBHisValid(pbh_table) --in form {p=,b=h=}

		if type(pbh_table) ~= "table" then 
			ba.print("Movements Warning: PBH table is not valid...\n")
			return false
		end

		local stop = false
		for _,v in ipairs({"p", "b", "h"}) do
			if type(pbh_table[v]) ~= "number" then
				stop = true
				break
			end
		end

		if stop then 
			return false 
		else
			return true --this means it is valid
		end	

	end

	function Movements:NormalizePBH(pbh, initial_pbh)  --in form {p=,b=h=}, initial comes from game so should already be normalized

		--Remember: 270 ends up being -90 and 360 ends up being 0
        if self:PBHisValid(pbh) then 
			local m3x3 = self:PBH_3x3(pbh)
            local pbh_adjusted = self:m3x3_to_PBH(m3x3)
			--initial is just if there is a target ship..
			--it's used just once in RunRotation, and in theory is not needed, but just keeping here as a failsafe
            if initial_pbh ~= nil and self:PBHisValid(initial_pbh) then
				local pi = math.pi
				local pi2 = pi*2
                for _,v in ipairs({"p", "b", "h"}) do
                    --only doing this if distance > 180 degrees
                    local initial = initial_pbh[v]
                    local final = pbh_adjusted[v]
                    if math.abs(final - initial) > pi then
                        local adjusted
                        --4 cases for initial and final angles: + with + or - and - with + or -
                        --1) + + (is initial > or final?)
                        if initial >= 0 and final >= 0 then
                            if initial > final then
                                --ie i=250 and f=10
                                adjusted = final + pi2
                            else --initial < final
                                --ie i=10 and f=250
                                adjusted = final - pi2
                            end
                        end
                        --2) + - 
                        if initial >= 0 and final < 0 then
                            --ie i=92 and f=-90
                            adjusted = final + pi2
                        end
                        --3) - + 
                        if initial < 0 and final >= 0 then
                            --ie i=-90 and f=250
                            adjusted = final - pi2
                        end
                        --4) - - (both are negative so already in same quandrant)
                        if adjusted ~= nil then
                            pbh_adjusted[v] = adjusted
                        end
                    end
                end
            end
			return pbh_adjusted
		else
			ba.print("Movements Error: input pbh value for function Movements : NormalizePBH() is invalid, returning input...\n")
			return pbh
		end

	end

	function Movements:Orientations_are_Equal(orientation_1, orientation_2, threshold)

		if orientation_1 == nil or orientation_2 == nil then return false end

		--set threshold default 
			--1 degree = 0.0174532925 rad
			--0.5 degree = 0.0174532925 rad
		threshold = threshold or 0.0174532925

		local abs = math.abs

		local not_equal
		for _, v in ipairs({"p", "b", "h"}) do
			if abs(orientation_1[v] - orientation_2[v]) > threshold then
				not_equal = true
				break
			end
		end

		if not_equal then
			return false
		else
			return true
		end 

	end

	function Movements:GetFinal_PBH(shipname, final_pbh, objecttarget_name) --final_pbh in {p=,b=,h=}

		if shipname == nil then return nil end 
		if not self:PBHisValid(final_pbh) then return nil end

		local pbh = {p=final_pbh.p, b=final_pbh.b, h=final_pbh.h}

		--if no target object set then run regular, if target object is set and it isn't present then don't run
		--has to be two separate ones to avoid case where there is a target object defined but it is not present
		--(^ie it would use the relative coordinates without the target ship)
		if type(objecttarget_name) ~= "string" then
			return pbh
		end

		--if it corresponds to a ship
		if type(objecttarget_name) == "string" then
			--if that object is in mission, then get p,b,h and add target p,b,h values
			local target_object = self:GetShip_or_Waypoint_Object(objecttarget_name)
			if target_object ~= nil and target_object:isValid() then
				local target_or = target_object.Orientation
				if target_or ~= nil then
					for k,v in pairs(pbh) do
						pbh[k] = v + target_or[k]
						--remember this is in radians
					end
					--make sure to normalize to what the game uses
					return self:NormalizePBH({p=pbh.p, b=pbh.b, h=pbh.h})
				end
			--else --if target object does not correspond to ship in mission (ie not arrived or dod) then don't do anything
			end
		end

		--if still here make sure to return nil 
		return nil

	end

	function Movements:WaypointName(waypointpath_name, waypoint_i)
	
		return waypointpath_name .. ":" .. waypoint_i
	
	end

	function Movements:GetShip_or_Waypoint_Object(objectname)

		if type(objectname) ~= "string" or objectname == "" then 
			ba.print("Movements Error: nil or empty provided to function for getting ship_or_waypoint...\n")
			return nil 
		end

		local function check_get_Waypoint(objectname)

			local object

			--if not ship then perhaps waypoint
			--first need to seperate path name and path point i

			local wp_path_name
			local wp_point_i
	
			local index = objectname:find(":", 0, true)
			if index ~= nil then
				wp_path_name = objectname:sub(1, index - 1)
				wp_point_i = objectname:sub(index+1, #objectname)
			end

			if wp_path_name ~= nil and wp_point_i ~= nil then
				wp_point_i = tonumber(wp_point_i)
				local wp_path = mn.WaypointLists[wp_path_name]
				if wp_path ~= nil and wp_path:isValid() and wp_path[wp_point_i] ~= nil and wp_path[wp_point_i]:isValid() then
					object = wp_path[wp_point_i]
				end
			end

			if object == nil then
				ba.print("Movements Error: nil or empty found for function for getting ship_or_waypoint...\n")
			end

			return object

		end

		--check if object is ship or waypoint
		local object = mn.Ships[objectname]
		if object == nil then
			object = check_get_Waypoint(objectname)
		end
		if not object:isValid() then
			object = check_get_Waypoint(objectname)
		end

		return object

	end

	function Movements:Set_Pos_Relative_to_Object(object_to_set_name, relative_target_name, offset_tbl, is_relative) --offset_tbl in form {0, 0, 0}

		local object_to_set = self:GetShip_or_Waypoint_Object(object_to_set_name)
		local relative_target = self:GetShip_or_Waypoint_Object(relative_target_name)

		if object_to_set == nil or relative_target == nil then 
			return 
		end

		local offset
		if type(offset_tbl) == "table" and #offset_tbl == 3 then
			offset = offset_tbl
		else
			offset = {0, 0, 0}
		end

		local new_vec
		if is_relative then
			new_vec = relative_target.Position + relative_target.Orientation:unrotateVector(ba.createVector(offset[1], offset[2], offset[3]))
		else
			new_vec = ba.createVector(relative_target.Position[1] + offset_x, relative_target.Position[2] + offset_y, relative_target.Position[3] + offset_z)
		end

		object_to_set.Position = ba.createVector(new_vec[1], new_vec[2], new_vec[3])

	end


	mn.LuaSEXPs["set-bank-constant"].Action = function(bank_constant, ...)

		if ba.MultiplayerMode then return end
		if #arg <= 0 then return end
		if type(bank_constant) ~= "number" then return end

		if bank_constant < 0 then 
			bank_constant = 0
		end

		for _, value in ipairs(arg) do
			local ship = value[1]
			if ship ~= nil and ship:isValid() then
				ship.Physics.BankingConstant = Movements:Round(bank_constant/100, 2)
			end
		end

	end

	mn.LuaSEXPs["set-deceleration-time"].Action = function(deceleration_time, ...)

		if ba.MultiplayerMode then return end
		if #arg <= 0 then return end
		if type(deceleration_time) ~= "number" then return end

		if deceleration_time < 0 then 
			deceleration_time = 0 
		end

		for _, value in ipairs(arg) do
			local ship = value[1]
			if ship ~= nil and ship:isValid() then
				ship.Physics.ForwardDecelerationTime = Movements:Round(deceleration_time/1000, 4)
			end
		end

	end


	function Movements:Add_Rotation(shipname, final_pbh, time_delay, time_for_rotation, play_dead_PR, targetobject_name) --requires pbh table in radians with {p=,b=,h=}

		--set times and keep everything positive
		--all times in seconds from sexp
		if shipname == nil then return end
		if not mn.Ships[shipname]:isValid() then return end

		local current_time = mn.getMissionTime()
		if type(time_delay) ~= "number" then
			time_delay = 0
		end
		if time_delay < 0 then
			time_delay = 0
		end
		if type(time_for_rotation) ~= "number" then
			time_for_rotation = -1
		end

		if not self:PBHisValid(final_pbh) then
			ba.print("Movements SEXP Warning: Add_Rotation() provided with invalid final_pbh, not running rotation...\n")
			return 
		end

		--add the entry to the active tracker table
		local ship = mn.Ships[shipname]

		if ship == nil then return end
		if not ship:isValid() then return end

		--only continue if engines are not blown out
		if mn.evaluateSEXP("( <= ( hits-left-subsystem-generic !"..shipname.."! !Engines! ) 0 )") then
			return
		end

		local initial_pbh = {p=ship.Orientation.p, b=ship.Orientation.b, h=ship.Orientation.h}

		--normalize pbh values
		final_pbh = self:NormalizePBH(final_pbh)
		local final_pbh_updated = self:NormalizePBH(final_pbh, initial_pbh)

		--for default find highest number within rotational vector
		--negative number runs default value --#TODO- default should just use tabled turn times
		if time_for_rotation < 0 then
			local physics = ship.Physics
			local pbh_list = {"p", "h", "b"} --this is the order in RotationalVelocityMax
			if physics ~= nil then
				local vels = physics.RotationalVelocityMax
				--note that these values are a modified version of the $Rotation time: values in ships.tbl
				--in ships.tbl the value is seconds to do a full rotation (2pi or 360 deg)
				--returned value from the physics handle is number of radians per second
				--ie 75 seconds/360 degrees = 1 second/ x degrees = 75 * x = 360 = 360/75 = 4.8 degrees = 0.083 radians
				--^this needs to match the order of the rotation vector (x,y,z)
				--calculate the longest rotation time
				if vels ~= nil then
					for i=1,3 do
						--calculate the largest magnitude of radians the ship has to transverse to get to the final orientation
						local k = pbh_list[i]
						local ship_k = self:Round(initial_pbh[k], 7)
						local final_k = self:Round(final_pbh_updated[k], 7)
						--^make sure ship_k and final_k are not pi! it causes a nan
						
						--angles already normalized to find shortest distance
						local angular_distance = math.abs(final_k - ship_k)
						
						--cap at pi radians (180 degrees)
						if angular_distance > 3.141592 then
							angular_distance = 3.141592
						end
						local angular_velocity = vels[i] --radians/sec
						--make sure we are NOT dividing by 0
						angular_velocity = self:Get_safe_number(angular_velocity, false, false, true) --iswholenumber, onlypositive, abovezero
						
						local l_time = angular_distance * (1/angular_velocity)
						
						if l_time > time_for_rotation then
							time_for_rotation = l_time
						end
						
					end
					
					--floor at 20% longest rotation time
					local floor_percent = 0.2
					local slowest_rotation_rate = math.min(vels[1], vels[2], vels[3])
					local slowest_rotation_time = 3.141592 * (1/slowest_rotation_rate) * 0.2
				
					if time_for_rotation < slowest_rotation_time then
						time_for_rotation = slowest_rotation_time
						--ba.print("Movements Status: Selected rotation duration of sec "..time_for_rotation.." for ship "..shipname.."...\n")
					end
					
				else
					ba.print("Movements Error: ship.Physics.RotationalVelocityMax == nil for ship "..shipname.."...\n")
				end
				--cap at max time/2
			else
				ba.print("Movements Error: ship.Physics == nil for ship "..shipname.."...\n")
			end
		end

		--set times, and double check default determined time for rotation
		local start_time = time_delay + current_time
		if type(time_for_rotation) ~= "number" then
			time_for_rotation = 0
		end
		if time_for_rotation < 0 then 
			time_for_rotation = 0
		end
		local end_time = start_time + time_for_rotation

		--run play dead order if needed, default is disabled
		--negative value turns off play dead order
		if type(play_dead_PR) ~= "number" then
			play_dead_PR = -1
		end

		--cap at 200 to avoid errors too, recall there is no floor
		if play_dead_PR > 200 then
			play_dead_PR = 200 
		end

		--run play dead if needed (ie not negative value)
		if play_dead_PR >= 0 then
			mn.runSEXP("( add-goal !"..shipname.."! ( ai-play-dead-persistent !"..play_dead_PR.."! ) )")
		end

		--add entry using shipname as key and update total number variable
		local entry = {
			shipname = shipname, 
			initial_pbh = initial_pbh,
			final_pbh = final_pbh, --this is the base final pbh we never want to change
			final_pbh_updated = final_pbh_updated, --this adds the target's orientation and can change, is set when rotation starts
			start_time = start_time, 
			end_time = end_time,
			play_dead_PR = play_dead_PR,
			isrotating = false,
			final_pbh_target_name = targetobject_name
		}

		self.Active_Rotations_Sum = self.Active_Rotations_Sum + 1

		self.Active_Rotations[shipname] = entry

	end

	function Movements:Remove_Rotation(shipname_key)

		if shipname_key == nil then return end
		local entry = self.Active_Rotations[shipname_key]

		--remove any play dead orders, remove from table and update tracker totals
		if entry ~= nil then
			--remove play dead order if it was using one
			if entry.play_dead_PR >= 0 then 
				mn.runSEXP("( remove-goal !"..entry.shipname.."! ( ai-play-dead-persistent !"..entry.play_dead_PR.."! ) )")
			end
			--set to nil and update tracker variables
			self.Active_Rotations[shipname_key] = nil
			self.Active_Rotations_Sum = self.Active_Rotations_Sum - 1
		end

	end

	function Movements:Run_Rotation()

		local mtime = mn.getMissionTime()

		--goes through list and rotates each entry based on time
		for _, v in pairs(self.Active_Rotations) do

			--only check and run if start time has come
			if mtime >= v.start_time and v.shipname ~= nil then
				--note: using both forcestop and no chop doesn't improve final pbh matching any better
				local percent_done = (mtime - v.start_time) / (v.end_time - v.start_time)

				if percent_done < 0 then
					percent_done = 0
				end

				if percent_done <= 1 then
					local continue_with_rotation = true

					--if ship rotation has not started then check and start it
					--this mitigates issues with delayed starts
					if not v.isrotating then
						local ship = mn.Ships[v.shipname]
						--update initial orientation with ships current orientation
						if ship ~= nil and ship:isValid() then
							local shipor = ship.Orientation

							v.isrotating = true

							for _,val in ipairs({"p","b","h"}) do
								v.initial_pbh[val] = shipor[val]
							end

							--update target ship's orientation if not nil
							local pbh_updated = self:GetFinal_PBH(v.shipname, v.final_pbh, v.final_pbh_target_name)
							--^ will be nil if tracker nil and also if targetobject_name is set but not in mission
							--^will also return pbh if no target ship set
							if pbh_updated ~= nil then
								--make sure to normalize to initial 
								pbh_updated = self:NormalizePBH(pbh_updated, v.initial_pbh)
								for k,val in pairs(pbh_updated) do
									v.final_pbh_updated[k] = val
								end
							else
								--if the target ship is gone then we don't need to rotate and we can set to nil 
								continue_with_rotation = false
								self:Remove_Rotation(v.shipname)
							end

						else
							--ship not valid so don't continue_with_rotation 
							continue_with_rotation = false
						end
					--else --already rotating so continue rotating
					end

					if continue_with_rotation then
						self:RotateToOrientation(v.shipname, v.initial_pbh, v.final_pbh_updated, percent_done)
					end

				else --if more then percent done, then remove from list
					--set ship orientation to final (though that should already be done and may cause a jerking motion?)
					self:RotateToOrientation(v.shipname, v.initial_pbh, v.final_pbh_updated, 1)
					if v.play_dead_PR >= 0 then 
						mn.runSEXP("( remove-goal !"..v.shipname.."! ( ai-play-dead-persistent !"..v.play_dead_PR.."! ) )")
					end

					--remove and update total variable
					self:Remove_Rotation(v.shipname)
				end
			end
		end

	end

	function Movements:PBH_Lerp(initial_pbh, final_pbh, percentdone)

		local pbh = {}
		for _,v in ipairs({"p","b","h"}) do
			pbh[v] = initial_pbh[v]*(1-percentdone) + final_pbh[v]*percentdone
		end

		return pbh

	end

	function Movements:RotateToOrientation(shipname, initial_pbh, final_pbh, percent_done)

		if initial_pbh ~= nil and final_pbh ~= nil and percent_done ~= nil and shipname ~= nil then
			local ship = mn.Ships[shipname]
			if ship ~= nil and ship:isValid() then
				--update ship orientation		
				local ort = self:PBH_Lerp(initial_pbh, final_pbh, percent_done)
				ship.Orientation = ba.createOrientation(ort.p, ort.b, ort.h)
			end
		end

	end

	mn.LuaSEXPs["move-to-orientation"].Action = function(ship, final_p, final_b, final_h, time_start_delay, time_for_effect, play_dead_priority)

		if ship ~= nil and ship:isValid() then

			if not Movements:PBHisValid({p=final_p, b=final_b, h=final_h}) then 
				ba.print("Movements SEXP Warning: move-to-orientation sexp provided with invalid final_pbh, not running rotation...\n")
				return 
			end

			local final_pbh = {
				p=math.rad(final_p), 
				b=math.rad(final_b), 
				h=math.rad(final_h)
			}

			--add entry
			--number checks are completed in function below 
			Movements:Add_Rotation(ship.Name, final_pbh, time_start_delay, time_for_effect, play_dead_priority)
		end

	end

	mn.LuaSEXPs["early-stop-move-to-orientation"].Action = function(ship)

		if ship ~= nil and ship:isValid() then
			Movements:Remove_Rotation(ship.Name)
		end

	end


	function Movements:Add_Wpt_trk_Object(waypointpath_name, objecttarget_name, waypoint_i, offset_xyz, track_interval, track_distance, userelative)
		
		--validity checks
		if waypointpath_name == nil or objecttarget_name == nil then return end
		
		if type(offset_xyz) == "table" then
			if #offset_xyz ~= 3 then
				offset_xyz = {0,0,0}
			end
		else
			offset_xyz = {0,0,0}
		end
		
		if type(track_interval) ~= "number" then
			track_interval = 1.0
		end
		if track_interval < 0 then
			track_interval = 0
		end
		
		if type(track_distance) ~= "number" then
			track_distance = 0
		end
		if track_distance < 0 then
			track_distance = 0
		end
		
		if type(waypoint_i) ~= "number" then
			waypoint_i = 1
		end

		if type(waypointpath_name) ~= "string" then return end
		if type(objecttarget_name) ~= "string" then return end
	
		--check if object is ship or waypoint
		local object = self:GetShip_or_Waypoint_Object(objecttarget_name)
		if object == nil then return end
		if not object:isValid() then return end
		
		local waypointpath = mn.WaypointLists[waypointpath_name]
		if waypointpath == nil then return end
		if not waypointpath:isValid() then return end
		
		local waypoint = waypointpath[waypoint_i]
		if waypoint == nil then return end
		if not waypoint:isValid() then return end
		local waypoint_name = self:WaypointName(waypointpath_name, waypoint_i)
		
		if type(userelative) ~= "boolean" then
			userelative = true
		end
		
		--add entry
		local entry = {
			waypoint_i = waypoint_i,
			waypointpath_name = waypointpath_name,
			objecttarget_name = objecttarget_name,
			offset_xyz = offset_xyz,
			track_interval = track_interval,
			time_last_check = mn.getMissionTime(),
			track_distance = track_distance, 
			userelative = userelative
		}
		self.Active_Wpts_trk_Objects[waypoint_name] = entry
		
		--set position if needed
		local dis_wp_to_object = waypoint.Position:getDistance(object.Position)
		if dis_wp_to_object > track_distance then
			self:Set_Pos_Relative_to_Object(waypoint_name, objecttarget_name, offset_xyz, userelative)
		end
		
		--update tracker variables
		self.Active_Wpts_trk_Objects_Sum = self.Active_Wpts_trk_Objects_Sum + 1
		
	end

	function Movements:Check_Wpt_trk_Object()

		if self.Active_Wpts_trk_Objects_Sum > 0 then
			local mtime = mn.getMissionTime()
			for k_waypointname, v in pairs(self.Active_Wpts_trk_Objects) do
				--only check if interval time has surpased
				if mtime > v.time_last_check + v.track_interval then
					v.time_last_check = mtime
					--validity checks
					local object = self:GetShip_or_Waypoint_Object(v.objecttarget_name)
					if object ~= nil and object:isValid() then
						local wppath = mn.WaypointLists[v.waypointpath_name]
						if wppath ~= nil and wppath:isValid() then
							local wpoint = wppath[v.waypoint_i]
							if wpoint ~= nil and wpoint:isValid() then
								--then only continue if target object has moved far enough
								local dis_wp_to_object = wpoint.Position:getDistance(object.Position)
								if dis_wp_to_object > v.track_distance then
									self:Set_Pos_Relative_to_Object(k_waypointname, v.objecttarget_name, v.offset_xyz, v.userelative)
								end
							end
						end
					end
				end
			end
		end

	end

	function Movements:Remove_Wpt_trk_Object(waypointname_key)
	
		if waypointname_key == nil then return end
		local entry = self.Active_Wpts_trk_Objects[waypointname_key]
		
		if entry ~= nil then
			self.Active_Wpts_trk_Objects[waypointname_key] = nil
			self.Active_Wpts_trk_Objects_Sum = self.Active_Wpts_trk_Objects_Sum - 1
		end
		
	end

	mn.LuaSEXPs["add-waypoint-track-ship"].Action = function(shiptarget, waypointpath, waypoint_i, offset_x, offset_y, offset_z, track_interval, track_distance, userelative)
		
		if waypointpath == nil or shiptarget == nil then return end
		if not waypointpath:isValid() or not shiptarget:isValid() then return end
		
		if type(offset_x) ~= "number" then
			offset_x = 0
		end
		if type(offset_y) ~= "number" then
			offset_y = 0
		end
		if type(offset_z) ~= "number" then
			offset_z = 0
		end
		
		track_interval = track_interval or 0
		if type(track_interval) ~= "number" then return end
		--function below takes this value in seconds not milliseconds
		track_interval = track_interval/1000
		
		local xyz_tbl = {offset_x, offset_y, offset_z}
		
		Movements:Add_Wpt_trk_Object(waypointpath.Name, shiptarget.Name, waypoint_i, xyz_tbl, track_interval, track_distance, userelative)
		
	end

	mn.LuaSEXPs["remove-waypoint-track-ship"].Action = function(waypointpath, waypoint_i)
	
		if waypointpath == nil then return end
		if not waypointpath:isValid() then return end
		
		if type(waypoint_i) ~= "number" then
			waypoint_i = 1
		end
		
		local waypoint = waypointpath[waypoint_i]
		if waypoint == nil then return end 
		if not waypoint:isValid() then return end
		
		local waypoint_name = Movements:WaypointName(waypointpath.Name, waypoint_i)
		Movements:Remove_Wpt_trk_Object(waypoint_name)
	
	end


	function Movements:TimeUntilStop(shipname)

		local stoptime = 0
		--gets ships current forward velocity and calculates time it will take to reach 0 forward velocity with max declaration
		if shipname ~= nil then
			local ship = mn.Ships[shipname]
			if ship ~= nil and ship:isValid() then
				local sphycis = ship.Physics
				if sphycis ~= nil then
					local current_speed_z = sphycis:getForwardSpeed()
					current_speed_z = self:Get_safe_number(current_speed_z) --iswholenumber, onlypositive, abovezero all default to true

					local max_speed_z = sphycis.VelocityMax[3]
					max_speed_z = self:Get_safe_number(max_speed_z)

					local decleration_time = sphycis.ForwardDecelerationTime
					decleration_time = self:Get_safe_number(decleration_time)

					local decleration_time_adjusted = decleration_time * 4.0 --(from object.cpp line 826, though it should be the damp *4)
					local percent_speed = current_speed_z/max_speed_z
					local stop_adusted = math.ceil ( decleration_time_adjusted * percent_speed )
					--^go the nearest second just to be safe
					--even going 10 m/s with 10 s declaration time it still takes ship 13 seconds to come to complete stop
					--stoptime = decleration_time + stop_adusted
					stoptime = math.ceil ( decleration_time * percent_speed )
					--^ this is not systematic at all, just based on observations and guesses
					--fortunately the ship will rotate no matter what
				end
			end
		end

		return stoptime

	end

	function Movements:Add_Ship_trk_Wpt(shipname, waypoint_path_name, priority, track_interval, track_distance, input_final_pbh, final_pbh_target_name, continuous_pbh_check, play_dead_PR) --input_final_pbh should be {p=0,b=0,h=0} in radians

		--validity checks
		if shipname == nil then return end
		if not mn.Ships[shipname]:isValid() then return end
		if waypoint_path_name == nil then return end
		if mn.WaypointLists[waypoint_path_name] == nil then return end
		
		if type(continuous_pbh_check) ~= "boolean" then
			continuous_pbh_check = true
		end

		--priority checks
		if type(priority) ~= "number" then
			priority = 100
		end
		if priority < 0 then
			priority = 0
		end

		--set play_dead_PR priority, default is disabled
		--recall this one CAN be negative and if so it disables the play dead persistent
		if type(play_dead_PR) ~= "number" then
			play_dead_PR = -1
		end
		--cap if too high
		if play_dead_PR > 200 then
			play_dead_PR = 200
		end
		--no floor since it can be negative

		local mtime = mn.getMissionTime()

		--default for track time interval
		track_interval = track_interval or 1.500
		if type(track_interval) ~= "number" then
			track_interval = 1.500
		end

		local ship = mn.Ships[shipname]

		local waypoint_path = mn.WaypointLists[waypoint_path_name]

		if waypoint_path[1] == nil then return end

		if not waypoint_path[1]:isValid() then return end

		local num_waypoints = #waypoint_path --remember only good for one frame, so don't add extra waypoints to this path

		local last_wp = waypoint_path[num_waypoints]
		local first_wp = waypoint_path[1]
		if last_wp == nil or first_wp == nil then return end

		if not last_wp:isValid() or not first_wp:isValid() then return end

		--set known waypoint location (use this to counter act ship over-shooting waypoint)
		local previous_waypoint_location = last_wp.Position

		--set default track distance to ship radius*1
		--negative value also uses default value
		if type(track_distance) ~= "number" then
			track_distance = -1
		end
		if track_distance < 0 then
			local class = ship.Class
			if class ~= nil then
				local model = class.Model
				if model ~= nil then
					track_distance = model.Radius
					if track_distance ~= nil then
						track_distance = track_distance*1
					end	
				end
			end
			if track_distance <= 0 then
				track_distance = 100
			end
		end

		--set final target pbh if available
		local final_pbh = {} --this is default, only change if the input had 3 number values
		if self:PBHisValid(input_final_pbh) then
			for _,v in ipairs({"p", "b", "h"}) do
				final_pbh[v] = input_final_pbh[v]
			end
		end

		--also set final target ship (will only work if final pbh set)
		if type(final_pbh_target_name) ~= "string" then
			final_pbh_target_name = nil
		end

		--add entry using shipname as key and update total number variable
		local entry = {
			shipname = shipname,
			waypoint_path_name = waypoint_path_name,
			num_waypoints = num_waypoints,
			priority = priority,
			play_dead_PR = play_dead_PR,
			track_interval = track_interval,
			time_last_check = mtime,
			previous_waypoint_location = previous_waypoint_location,
			track_distance = track_distance,
			is_running_waypoints_once = false,
			final_pbh = final_pbh, --remember needs to be in radians
			final_pbh_target_name = final_pbh_target_name,
			continuous_pbh_check = continuous_pbh_check
		}

		--only give it the order if the ship is far enough away from the first waypoint
		local dis_to_wp1 = first_wp.Position:getDistance(ship.Position)
		if dis_to_wp1 > track_distance then
			--give initial waypoint order
			mn.runSEXP("( add-goal !"..shipname.."! ( ai-waypoints-once !"..waypoint_path_name.."! !"..priority.."! ))")
			entry.is_running_waypoints_once = true
		end

		self.Active_Ships_trk_Wpts_Sum = self.Active_Ships_trk_Wpts_Sum + 1

		self.Active_Ships_trk_Wpts[shipname] = entry

	end

	function Movements:Remove_Ship_trk_Wpt(shipname_key)
	
		if shipname_key == nil then return end
		local entry = self.Active_Ships_trk_Wpts[shipname_key]
		
		if entry ~= nil then
			--remove any play dead order 
			if entry.play_dead_PR >= 0 then 
				mn.runSEXP("( remove-goal !" .. entry.shipname .."! ( ai-play-dead-persistent !".. entry.play_dead_PR .."! ) )")
			end
			--remove any waypoints once order
			mn.runSEXP("( remove-goal !" .. entry.shipname .."! ( ai-waypoints-once !".. entry.waypoint_path_name .."! !".. entry.priority .."! ) )")
			--remove from list and update variables
			self.Active_Ships_trk_Wpts[shipname_key] = nil
			self.Active_Ships_trk_Wpts_Sum = self.Active_Ships_trk_Wpts_Sum - 1
		end
		
	end

	function Movements:Pause_Ship_trk_Wpt(shipname, done_wp_path_name)

		--change waypoint status and save location of last waypoint

		--validity checks
		if shipname == nil or done_wp_path_name == nil then return end 
		local entry = self.Active_Ships_trk_Wpts[shipname]
		if entry == nil then return end

		--only continue if the completed waypoint was the one specified in tracker goal
		if entry.waypoint_path_name ~= done_wp_path_name then return end

		--if there is a target orientation then run rotate-to-orientation sexp
		if self:PBHisValid(entry.final_pbh) and self.Active_Rotations[shipname] == nil then
			--need time delay so the craft is not moving forward anymore
			local rotate_delay = self:TimeUntilStop(shipname)
			--calculate how long until it stops

			local rotate_time = -1 --for default rotate time
			self:Add_Rotation(shipname, entry.final_pbh, rotate_delay, rotate_time, entry.play_dead_PR, entry.final_pbh_target_name)
		--if not valid final orientation then don't run rotate-to-orientation
		end

		--change status
		entry.is_running_waypoints_once = false

		--remove play dead persistent order 
		if entry.play_dead_PR >= 0 then 
			mn.runSEXP("( remove-goal !" .. entry.shipname .."! ( ai-play-dead-persistent !".. entry.play_dead_PR .."! ) )")
		end

		--save last known waypoint location
		--using last known location of last waypoint helps mitigate effects of the ship over-shooting the final waypoint
		if entry.previous_waypoint_location ~= nil and entry.waypoint_path_name ~= nil then
			local wppath = mn.WaypointLists[entry.waypoint_path_name]
			if wppath ~= nil and wppath:isValid() and entry.num_waypoints ~= nil then
				local lastwp = wppath[entry.num_waypoints]
				if lastwp ~= nil and lastwp:isValid() and entry.previous_waypoint_location ~= nil then
					entry.previous_waypoint_location = lastwp.Position
				end
			end
		end

	end

	function Movements:ShouldUpdate_PBH(old_pbh, new_pbh)

		if not self:PBHisValid(old_pbh) or not self:PBHisValid(new_pbh) then return false end
		local answer = false 
		local diff = 0.02 --math.deg(0.02) = 1.14 degrees
		for _,v in pairs({"p", "b", "h"}) do
			local old, new = old_pbh[v], new_pbh[v]
			if math.abs(old - new) > diff then
				answer = true
				break
			end
		end

		return answer 

	end

	function Movements:Check_Ship_trk_Wpt()
	
		if self.Active_Ships_trk_Wpts_Sum > 0 then
			local mtime = mn.getMissionTime()

			for _, v in pairs(self.Active_Ships_trk_Wpts) do

				--first only check if ship is not already running ai-waypoints-once order
				--also make sure ship is not actively running a rotate-to-orientation order
				if not v.is_running_waypoints_once and self.Active_Rotations[v.shipname] == nil then

					--then only continue if the tracker time has elapsed 
					if mtime > v.time_last_check + v.track_interval  then
						v.time_last_check = mtime
						local wpname = v.waypoint_path_name
						local ship = mn.Ships[v.shipname]

						--validity checks
						if wpname ~= nil and ship ~= nil and ship:isValid() then

							--at this point run the orientation if the previous orientation is substantially different 
							--only run if we are using that boolean option
							if v.continuous_pbh_check then
								local so = ship.Orientation --start orientation
								local fo = self:GetFinal_PBH(v.shipname, v.final_pbh, v.final_pbh_target_name) --final_pbh in {p=,b=,h=}
								if self:Orientations_are_Equal(so, fo, 0.02) then 
									local rotate_time = -1 --for default rotate time
									local rotate_delay = 1
									self:Add_Rotation(v.shipname, v.final_pbh, rotate_delay, rotate_time, v.play_dead_PR, v.final_pbh_target_name)
									--^ add rotation updates the previous pitch, bank, heading of any ship in the Active_Ships_trk_Wpts
								end
							end

							--then only continue if last waypoint has moved far enough
							local wppath = mn.WaypointLists[wpname]

							--don't move to waypoints if we have added a rotation to do
							if self.Active_Rotations[v.shipname] == nil and wppath ~= nil and wppath:isValid() then
								local lastwp = wppath[v.num_waypoints]
								if lastwp ~= nil and lastwp:isValid() then
									local dis_wp_previous_to_wp = lastwp.Position:getDistance(v.previous_waypoint_location)
									--see if distance between last waypoint path and ship is too far
									--and if distance between waypoint's last location and it's possible new location is too far
									--using last known location of last waypoint helps mitigate effects of the ship overshootinng the final waypoint
									--remove play dead persistent order 
									--add goal and set to tracking
									if dis_wp_previous_to_wp > v.track_distance then
										--remove play dead persistent
										if v.play_dead_PR >= 0 then 
											mn.runSEXP("( remove-goal !" .. v.shipname .."! ( ai-play-dead-persistent !".. v.play_dead_PR .."! ) )")
										end
										--start waypoints once
										mn.runSEXP("( add-goal !"..v.shipname.."! ( ai-waypoints-once !"..v.waypoint_path_name.."! !"..v.priority.."! ))")
										v.is_running_waypoints_once = true
									end
								end
							end
						end
					end
				end
			end
		end

	end

	mn.LuaSEXPs["add-ai-goal-track-waypoint"].Action = function(ship, waypointpath, priority, track_interval, track_distance)

		--recall this doesn't take into account target ship, so nothing about the orientation, continuous_pbh_check, or play_dead_PR is set here. 
		--this should only be used for waypoints not related to ships, if more is needed use the actual function

		if ship ~= nil and ship:isValid() then

			--add entry
			--number checks are completed in function below 
			--track_interval in sexp is in milliseconds so convert it to seconds 
			track_interval = track_interval or 1500
			if type(track_interval) ~= "number" then return end
			track_interval = track_interval/1000

			--function takes a waypoint_path_name as string but this sexp takes the entire waypoint_path object
			local waypointpath_name = waypointpath.Name

			Movements:Add_Ship_trk_Wpt(ship.Name, waypointpath_name, priority, track_interval, track_distance) --recall target is not used in this sexp, so it won't be used
		end

	end

	mn.LuaSEXPs["remove-ai-goal-track-waypoint"].Action = function(ship)
		if ship ~= nil and ship:isValid() then
			--number checks are completed in function below 
			Movements:Remove_Ship_trk_Wpt(ship.Name)
		end	
	end


	function Movements:Set_Idle_Tracking_PBH(shipname, pitch, bank, heading, targetobject_name, continuous_pbh_check) --remember needs to be in radians

		--use this to update or set the idle orientation of a ship tracking a waypoint
		--remember needs to be in radians
		if shipname == nil then return end
		local entry = self.Active_Ships_trk_Wpts[shipname]
		if entry == nil then return end
		if type(continuous_pbh_check) ~= "boolean" then continuous_pbh_check = true end
		if type(pitch) == "number" and type(bank) == "number" and type(heading) == "number" then
			--update pbh
			local input_pbh = {p=pitch, b=bank, h=heading}
			for k,v in pairs(input_pbh) do
				entry.final_pbh[k] = v
			end

			--update continuous_pbh_check
			entry.continuous_pbh_check = continuous_pbh_check

			--update target ship
			if type(targetobject_name) == "string" then
				entry.final_pbh_target_name = targetobject_name
			else
				entry.final_pbh_target_name = nil
			end
		end

	end

	function Movements:Unset_Idle_Tracking_PBH(shipname_key)
		
		--use this to remove the idle tracking function for a ship that is tracking a waypoint path
		if shipname_key == nil then return end
		if type(shipname_key) ~= "string" then return end
		local entry = self.Active_Ships_trk_Wpts[shipname_key]
		if entry == nil then return end
		
		entry.final_pbh = {}
		entry.final_pbh_target_name = nil
		entry.continuous_pbh_check = false
		
	end

	mn.LuaSEXPs["set-idle-track-orientation"].Action = function(ship, pitch, bank, heading, usetargetship, input_targetship, continuous_pbh_check)
		
		if ship ~= nil and ship:isValid() then
			--if target ship is specified only run if it's in mission
			if usetargetship == nil then
				usetargetship = false
			end
			local targetobject_name
			if usetargetship then --if false then it's nil
				if input_targetship == nil then return end
				if not input_targetship:isValid() then return end
				--^those function termination lines prevent set idle tracking from running with a nil target ship, because the target is not really supposed to be nil (it just hasn't arrived yet or is dod) 
				if input_targetship:isValid() then
					targetobject_name = input_targetship.Name
				end
			end
			
			if not Movements:PBHisValid({p=pitch, b=bank, h=heading}) then 
				ba.print("Movements SEXP Warning: set-idle-track-orientation sexp provided with invalid pitch, bank, or heading values, not setting orientation...\n")
				return 
			end
			
			Movements:Set_Idle_Tracking_PBH(ship.Name, math.rad(pitch), math.rad(bank), math.rad(heading), targetobject_name, continuous_pbh_check)
		end
		
	end

	mn.LuaSEXPs["unset-idle-track-orientation"].Action = function(ship)
		
		if ship ~= nil and ship:isValid() then
			Movements:Unset_Idle_Tracking_PBH(ship.Name)
		end
		
	end


	function Movements:GetRadius(shipname, donotround) --gets radius of ship

		local final = 100

		if shipname ~= nil then
			local ship = mn.Ships[shipname]
			if ship ~= nil and ship:isValid() then
				local class = ship.Class
				if class ~= nil then
					local model = class.Model
					if model ~= nil then
						local radius = model.Radius
						if radius ~= nil then
							if donotround then
								final = radius
							else
								final = self:Round(radius)
							end
						end	
					end
				end
			end
		end
		return final

	end

	function Movements:Add_Ship_trk_Ship(ship_to_order_name, ship_to_track_name, waypointpath_name, waypoint_i, priority, offset, pbh, userelative, continuous_pbh_check, play_dead_PR) --pbh should be in radians
		--higher level function that runs all the above functions
		--recall this has access to some other arguments that the individual lower level sexps do not such as userelative, continuous_pbh_check, and play_dead_PR

		--set defaults 
		if type(ship_to_order_name) ~= "string" then return end
		if type(ship_to_track_name) ~= "string" then return end
		if type(waypointpath_name) ~= "string" then return end
		if type(waypoint_i) ~= "number" then
			waypoint_i = 1
		end
		if waypoint_i < 0 then
			waypoint_i = 1
		end
		local track_interval = 1.0 --default
		local track_distance = 0	--default

		local offset_xyz
		local default_offset = ( self:GetRadius(ship_to_order_name) + self:GetRadius(ship_to_track_name) ) * 1.5
		if type(offset) == "table" and type(offset[1]) == "number" and type(offset[2]) == "number" and type(offset[3]) == "number" then
			offset_xyz = offset
		else
			offset_xyz = {default_offset, default_offset, default_offset}
		end

		local idle_pbh = {} --if blank then does not rotate at end
		if self:PBHisValid(pbh) then
			for _,v in ipairs({"p", "b", "h"}) do
				idle_pbh[v] = pbh[v]
			end
		end

		--run waypoint track ship 
		self:Add_Wpt_trk_Object(waypointpath_name, ship_to_track_name, waypoint_i, offset_xyz, track_interval, track_distance, userelative)

		--run ship track waypoint, include setting 
		local track_distance_ship = -1 --so it uses default ship radius
		--other defaults and validity checks are performed in function below
		self:Add_Ship_trk_Wpt(ship_to_order_name, waypointpath_name, priority, track_interval, track_distance_ship, idle_pbh, ship_to_track_name, continuous_pbh_check, play_dead_PR)

	end

	function Movements:Remove_Ship_trk_Ship(shipname_to_remove_order, waypointpath_name, waypoint_i)
		
		--validity checks
		if type(shipname_to_remove_order) ~= "string" then return end
		--if type(ship_to_track_name) ~= "string" then return end
		if type(waypointpath_name) ~= "string" then return end
		if type(waypoint_i) ~= "number" then
			waypoint_i = 1
		end
		--first stop waypoint tracking ship, using sexp so can use waypointpath name and i
		mn.runSEXP("( remove-waypoint-track-ship !"..waypointpath_name.."! !"..waypoint_i.."! )")
		
		--then remove ship_order tracking of that waypoint 
		self:Remove_Ship_trk_Wpt(shipname_to_remove_order)
		
	end

	mn.LuaSEXPs["add-ai-goal-track-ship"].Action = function(ship_to_order, ship_to_track, waypointpath, priority, off_x, off_y, off_z, pbh_p, pbh_b, pbh_h, userelative, continuous_pbh_check, play_dead_PR)
		
		if ship_to_order == nil or ship_to_track == nil or waypointpath == nil then return end
		if not ship_to_order:isValid() or not ship_to_track:isValid() or not waypointpath:isValid() then return end
		
		local ship_to_order_name = ship_to_order.Name
		local ship_to_track_name = ship_to_track.Name
		local waypointpath_name = waypointpath.Name
		
		if type(pbh_p) ~= "number" then
			pbh_p = 0
		end
		if type(pbh_b) ~= "number" then
			pbh_b = 0
		end
		if type(pbh_h) ~= "number" then
			pbh_h = 0
		end
		
		pbh_p = math.rad(pbh_p)
		pbh_b = math.rad(pbh_b)
		pbh_h = math.rad(pbh_h)
		
		local waypoint_i = 1

		local offset = {off_x, off_y, off_z}
		local pbh = {p=pbh_p, b=pbh_b, h=pbh_h}
		
		Movements:Add_Ship_trk_Ship(ship_to_order_name, ship_to_track_name, waypointpath_name, waypoint_i, priority, offset, pbh, userelative, continuous_pbh_check, play_dead_PR)
		
	end
	
	mn.LuaSEXPs["remove-ai-goal-track-ship"].Action = function(ship_to_remove_order, waypointpath, waypoint_i)
	
		if ship_to_remove_order == nil or waypointpath == nil then return end
		if not ship_to_remove_order:isValid() or not waypointpath:isValid() then return end
		
		local ship_to_remove_order_name = ship_to_remove_order.Name
		--local ship_to_stop_track_name = ship_to_stop_track.Name
		local waypointpath_name = waypointpath.Name		
	
		Movements:Remove_Ship_trk_Ship(ship_to_remove_order_name, waypointpath_name, waypoint_i)
	
	end


	function Movements:Ship_DoD_Remove(shipname)
		
		--goes through all movements lists and removes entries of that ship where needed to save memory
		if type(shipname) ~= "string" then return end
		
		--stop any rotations
		self:Remove_Rotation(shipname)
		
		--go through waypoints track ship and search for this ship name 
		if self.Active_Wpts_trk_Objects_Sum > 0 then
			for k_waypointname, v in pairs(self.Active_Wpts_trk_Objects) do
				if v.objecttarget_name == shipname then
					self:Remove_Wpt_trk_Object(k_waypointname)
				end
			end
		end
		
		--remove any idle orientations that are using this ship has a relative orientation base
		if self.Active_Ships_trk_Wpts_Sum > 0 then
			for _, v in pairs(self.Active_Ships_trk_Wpts) do
				if v.final_pbh_target_name == shipname then
					v.final_pbh = {}
					v.final_pbh_target_name = nil
				end
			end
		end		
		
		--remove any ship tracking waypoints 
		self:Remove_Ship_trk_Wpt(shipname)
		
	end

	function Movements:OnSimulation()

		if self.is_enabled then
			local current_time = mn.getMissionTime()
			if current_time > 0.1 then
				--update rotations --now done on Simulation
				if self.Active_Rotations_Sum > 0 then
					self:Run_Rotation()
				end
				--update current time and check waypoints
				if current_time > self.Time_Previous_Check + self.G_Time_Check_Interval then
					self.Time_Previous_Check = current_time
					--check waypoints tracking ships
					if self.Active_Wpts_trk_Objects_Sum > 0 then
						self:Check_Wpt_trk_Object()
					end 
					--check ships tracking waypoints
					if self.Active_Ships_trk_Wpts_Sum > 0 then
						self:Check_Ship_trk_Wpt()
					end
				end
			end	
		end

	end

]


$State: GS_STATE_GAME_PLAY

$On Gameplay Start: [
	if Movements then
		Movements:Initiate()
	end
]

$On Waypoints Done: [
	local hs = hv.Ship
	local hswpp = hv.Waypointlist
	if Movements and Movements.is_enabled and hs ~= nil and hs:isValid() and hswpp ~= nil and hswpp:isValid() then
		Movements:Pause_Ship_trk_Wpt(hs.Name, hswpp.Name)
	end
]

$On Ship Death Started: [
	local hook_ship = hv.Ship
	if Movements and Movements.is_enabled and hook_ship ~= nil and hook_ship:isValid() and hook_ship:getBreedName() == "Ship" then
		local shipname = tostring(hook_ship)
		Movements:Ship_DoD_Remove(shipname)
	end
]

$On Warp Out: [
	--also checking for warpout just because it triggers sooner
	--perfectly safe to remove many times because it only removes it if it is on the list
	local hook_ship = hv.Self
	if Movements and Movements.is_enabled and hook_ship ~= nil and hook_ship:isValid() then
		Movements:Ship_DoD_Remove(hook_ship.Name)
	end	
]

$On Ship Depart: [
	local hook_ship = hv.Ship
	if Movements and Movements.is_enabled and hook_ship ~= nil and hook_ship:isValid() then
		Movements:Ship_DoD_Remove(hook_ship.Name)
	end	
]

$On Goals Cleared: [
	local hook_ship = hv.Ship
	if Movements and Movements.is_enabled and hook_ship ~= nil and hook_ship:isValid() then
		local shipname = hook_ship.Name
		Movements:Remove_Rotation(shipname)
		Movements:Remove_Ship_trk_Wpt(shipname)
	end		
]

$On State End: [
	if Movements then
		Movements:Initiate()
	end
]


#End