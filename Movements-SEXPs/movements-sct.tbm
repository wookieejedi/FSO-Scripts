#Global Hooks

$Simulation: [
	if Movements then
		Movements:OnSimulation()
	end
]

#End

#Conditional Hooks

$Application: FS2_Open

$On Game Init: [

	--Version 2.4, released on Janurary 17, 2023 by wookieejedi
	--Requires FSO build of August 27, 2022 or newer
	--Description: custom sexps and functions that allow for much easier ship movements and rotations
	--Usage: custom sexps are included and listed in FRED under the LUA-Movements tab

	Movements = {} --makes a global variable! This is the only global variable this script creates.

	function math.atan2safe(y, x)
			
		local ang 
		local pi = math.pi
		local pi2 = pi/2.0
		
		if x == 0 then 
		
			if y == 0 then
				ang = 0
			elseif y > 0 then
				ang = pi2
			else
				ang = -pi2
			end
			return ang
			
		end
		
		ang = math.atan(y/x)
		if x < 0 then
			ang = ang + pi
		end
		
		return ang
		
	end

	function Movements:Initiate()

		--remember that a ship not in mission will be nil in lua sexp if input parameter is type ship 
		self.Time_Previous_Check = 0
		self.G_Time_Check_Interval = 0.1
		self.Active_Rotations = {}
		self.Active_Rotations_Sum = 0
		self.Active_Ships_trk_Wpts = {}
		self.Active_Ships_trk_Wpts_Sum = 0
		self.Active_Wpts_trk_Objects = {}
		self.Active_Wpts_trk_Objects_Sum = 0

		if ba.MultiplayerMode then
			if multi:isServer() then
				self.is_enabled = true
			else
				self.is_enabled = false
			end
		else
			self.is_enabled = true
		end

	end

	function Movements:Round(input_number, numDecimalPlaces) --if no number of decimals is specified then it defaults to 0

		local output
		input_number = tonumber(input_number)
		if numDecimalPlaces == nil then numDecimalPlaces = 0 end

		if numDecimalPlaces == 0 then
			output = math.floor(math.floor(input_number + 0.5))
		end

		if numDecimalPlaces > 0 then
			local mult = 10^numDecimalPlaces
			output = math.floor(input_number * mult + 0.5) / mult
		end

		return output

	end

    function Movements:PBH_3x3(pbh) --input is radians
            
        local p, b, h = pbh.p, pbh.b, pbh.h
        
        local sinp = math.sin(p)
        local cosp = math.cos(p)
        local sinb = math.sin(b)
        local cosb = math.cos(b)
        local sinh_ = math.sin(h)
        local cosh_ = math.cos(h)
        local sbsh = sinb*sinh_
        local cbch = cosb*cosh_
        local cbsh = cosb*sinh_
        local sbch = sinb*cosh_

        local vals ={
            cbch + (sinp*sbsh), --1
            (sinp*cbsh) - sbch, --2
            sinh_*cosp, --3
            sinb*cosp, --4
            cosb*cosp, --5
            -sinp, --6
            sinp*sbch - cbsh,--7
            sbsh + (sinp*cbch), --8
            cosh_*cosp--9
        }
        
        for i,v in ipairs(vals) do
            vals[i] = self:Round(v,6)
        end

        local finalm = {{vals[1],vals[4],vals[7]},{vals[2],vals[5],vals[8]},{vals[3],vals[6],vals[9]}}
        
        return finalm 
        
    end

    function Movements:m3x3_to_PBH(m3x3) --gets PBH in radians

        local rvec = m3x3[1]
        local uvec = m3x3[2]
        local fvec = m3x3[3]

        local heading = math.atan2safe(fvec[1], fvec[3]) 

        local sinh = math.sin(heading)
        local cosh = math.cos(heading)
        local cosp

        if math.abs(sinh) > math.abs(cosh) then
            cosp = fvec[1] * sinh
        else
            cosp = fvec[3] * cosh
        end

        local fvec_xz_distance = math.sqrt( (fvec[1] * fvec[1]) + (fvec[3] * fvec[3]) ) --( fvec.xyz.x^2 + fvec.xyz.z^2 )^0.5

        local pitch = math.atan2safe(-fvec[2], fvec_xz_distance) --<gives correct pitch 

        local bank 

        if cosp == 0 then
            bank = 0
        else
            local sinb = rvec[2] / cosp
            local cosb = uvec[2] / cosp
            
            bank = math.atan2safe(sinb, cosb)
        end

        --ba.print("pitch: "..math.deg(pitch)..", bank:"..math.deg(bank)..", heading:"..math.deg(heading))
        return {p=pitch, b=bank, h=heading}
        
    end

	function Movements:PBHisValid(pbh_table) --in form {p=,b=h=}

		if type(pbh_table) ~= "table" then 
			--ba.print("Movements Warning: PBH table is not valid...\n")
			return false
		end

		local stop = false
		for _,v in ipairs({"p", "b", "h"}) do
			if type(pbh_table[v]) ~= "number" then
				stop = true
				break
			end
		end

		if stop then 
			return false 
		else
			return true --this means it is valid
		end	

	end

	function Movements:NormalizePBH(pbh_to_normalize, pbh_initial)  --in form {p=,b=h=}, initial comes from game so should already be normalized

		--Remember: 270 ends up being -90 and 360 ends up being 0
        if self:PBHisValid(pbh_to_normalize) then 
			local m3x3 = self:PBH_3x3(pbh_to_normalize)
            local pbh_adjusted = self:m3x3_to_PBH(m3x3)
			--initial is just if there is a target ship..
			--it's used just once in RunRotation, and in theory is not needed, but just keeping here as a failsafe
            if pbh_initial ~= nil and self:PBHisValid(pbh_initial) then
				local pi = math.pi
				local pi2 = pi*2
                for _,v in ipairs({"p", "b", "h"}) do
                    --only doing this if distance > 180 degrees
                    local initial = pbh_initial[v]
                    local final = pbh_adjusted[v]
                    if math.abs(final - initial) > pi then
                        local adjusted
                        --4 cases for initial and final angles: + with + or - and - with + or -
                        --1) + + (is initial > or final?)
                        if initial >= 0 and final >= 0 then
                            if initial > final then
                                --ie i=250 and f=10
                                adjusted = final + pi2
                            else --initial < final
                                --ie i=10 and f=250
                                adjusted = final - pi2
                            end
                        end
                        --2) + - 
                        if initial >= 0 and final < 0 then
                            --ie i=92 and f=-90
                            adjusted = final + pi2
                        end
                        --3) - + 
                        if initial < 0 and final >= 0 then
                            --ie i=-90 and f=250
                            adjusted = final - pi2
                        end
                        --4) - - (both are negative so already in same quandrant)
                        if adjusted ~= nil then
                            pbh_adjusted[v] = adjusted
                        end
                    end
                end
            end
			return pbh_adjusted
		else
			ba.print("Movements Error: input pbh value for function Movements : NormalizePBH() is invalid, returning input...\n")
			return pbh_to_normalize
		end

	end

	function Movements:Orientations_are_Equal(orientation_1, orientation_2, threshold)

		if orientation_1 == nil or orientation_2 == nil then return false end

		--set threshold default (tests work with all the following)
			--1 degree = 0.0174532925 rad
			--0.5 degree = 0.00872665 rad
			--0.25 degree = 0.004363323 rad
		threshold = threshold or 0.00872665

		local abs = math.abs

		local not_equal
		for _, v in ipairs({"p", "b", "h"}) do
			if abs(orientation_1[v] - orientation_2[v]) > threshold then
				not_equal = true
				break
			end
		end

		if not_equal then
			return false
		else
			return true
		end 

	end

	function Movements:GetFinal_PBH(ship, final_pbh, objecttarget_name, face_torward_target) --final_pbh in {p=,b=,h=}

		if ship == nil then return nil end 
		if not ship:isValid() then return nil end
		if not self:PBHisValid(final_pbh) then return nil end

		local pbh = {p=final_pbh.p, b=final_pbh.b, h=final_pbh.h}

		--if no target object set then run regular, if target object is set and it isn't present then don't run
		--has to be two separate ones to avoid case where there is a target object defined but it is not present
		--(^ie it would use the relative coordinates without the target ship)
		if type(objecttarget_name) ~= "string" then
			return pbh
		end

		if face_torward_target == nil then
			face_torward_target = false
		end

		--if it corresponds to a ship
		if type(objecttarget_name) == "string" then
			--if that object is in mission
			local target_object = self:Get_Ship_or_Wpt_Obj_from_name(objecttarget_name)
			if target_object ~= nil and target_object:isValid() then
				--if target valid check which type of final pbh is needed
				if face_torward_target then
					--face to target, so do that math
					local position_diff = target_object.Position - ship.Position
					local norm_diff = position_diff:getNormalized()
					local pbh = norm_diff:getOrientation()
					return self:NormalizePBH({p=pbh.p, b=pbh.b, h=pbh.h})
				else
					--target is relative, so add pbh
					local target_or = target_object.Orientation
					if target_or ~= nil then
						for k,v in pairs(pbh) do
							pbh[k] = v + target_or[k]
							--remember this is in radians
						end
						--make sure to normalize to what the game uses
						return self:NormalizePBH({p=pbh.p, b=pbh.b, h=pbh.h})
					--else return nil
					end
				end
			--else return nil --if target object does not correspond to ship in mission (ie not arrived or dod) then don't do anything
			end
		end

		--if still here make sure to return nil 
		return nil

	end

	function Movements:WaypointName(waypointpath_name, waypoint_i)

		return waypointpath_name .. ":" .. waypoint_i

	end

	function Movements:Set_Pos_Relative_to_Object(object_to_set_name, relative_target_name, offset_tbl, is_relative) --offset_tbl in form {0, 0, 0}

		local object_to_set = self:Get_Ship_or_Wpt_Obj_from_name(object_to_set_name)
		local relative_target = self:Get_Ship_or_Wpt_Obj_from_name(relative_target_name)

		if object_to_set == nil or relative_target == nil then 
			return 
		end

		local offset
		if type(offset_tbl) == "table" and #offset_tbl == 3 then
			offset = offset_tbl
		else
			offset = {0, 0, 0}
		end

		local new_vec
		if is_relative then
			new_vec = relative_target.Position + relative_target.Orientation:unrotateVector(ba.createVector(offset[1], offset[2], offset[3]))
		else
			new_vec = ba.createVector(relative_target.Position[1] + offset[1], relative_target.Position[2] + offset[2], relative_target.Position[3] + offset[3])
		end

		object_to_set.Position = ba.createVector(new_vec[1], new_vec[2], new_vec[3])

	end

	function Movements:Get_Ship_or_Wpt_Obj_from_name(objectname)

		if type(objectname) ~= "string" or objectname == "" then 
			ba.print("Movements Error: nil or empty object name provided to function for getting ship_or_waypoint object from name...\n")
			return nil 
		end

		local function check_get_Waypoint(objectname)

			local object_wp

			--if not ship then perhaps waypoint
			--first need to seperate path name and path point i

			local wp_path_name
			local wp_point_i

			local index = objectname:find(":", 0, true)
			if index ~= nil then
				wp_path_name = objectname:sub(1, index - 1)
				local wp_point_i_str = objectname:sub(index+1, #objectname)
				if wp_point_i_str ~= nil then 
					wp_point_i = tonumber(wp_point_i_str)
				end
			end

			--might have been supplied with waypoint path name
			--so use object name then check if waypoint path actually valid
			if wp_path_name == nil then
				wp_path_name = objectname
				wp_point_i = 1
			end

			--set and check waypoint path and point
			local wp_path = mn.WaypointLists[wp_path_name]

			if wp_path ~= nil and wp_path:isValid() and wp_point_i ~= nil and wp_path[wp_point_i] ~= nil and wp_path[wp_point_i]:isValid() then
				object_wp = wp_path[wp_point_i]
			end

			if object_wp == nil then
				ba.print("Movements Error: nil or empty found for function for getting check_get_Waypoint...\n")
			end

			return object_wp

		end

		--check if object is ship or waypoint
		local object = mn.Ships[objectname]
		if object == nil then
			object = check_get_Waypoint(objectname)
		end
		if not object:isValid() then
			object = check_get_Waypoint(objectname)
		end

		return object

	end

	function Movements:Get_name_from_Ship_or_Wpt_Obj(obj)

		local object_name

		if obj ~= nil and obj:isValid() then

			local obj_breed = obj:getBreedName()

			if obj_breed == "Ship" then
				object_name = obj.Name
			elseif obj_breed == "Waypoint" then
				local waypoint_list = obj:getList()
				if waypoint_list ~= nil and waypoint_list:isValid() then
					--tostring on waypoints does not work, so use a workaround for now
					--get signature of object and loop through all waypoints until we find a match, then save the name
					local num_waypoints = #waypoint_list
					local sig_obj = obj:getSignature()
					for i=1,num_waypoints do
						local wypt = waypoint_list[i]
						if wypt ~= nil and wypt:isValid() and wypt:getSignature() == sig_obj then
							object_name = waypoint_list.Name..":"..tostring(i)
						end
					end
				end
			end

		end

		return object_name

	end

	function Movements:GetMatchingOrder_i(ship, removing_order_priority, removing_order_string, target_of_removing_order_string) --currently supported are "ai-play-dead-persistent" and "ai-waypoints-once"

		local matching_order_i

		if self.is_enabled and ship ~= nil and ship:isValid() then
			--go through orders and find matching
			local orders = ship.Orders
			local num_ords = #orders

			--find matching
			if num_ords > 0 then
				for i=1,num_ords do
					local ord = orders[i]
					--check priority match first
					if ord.Priority == removing_order_priority then
						local ord_typ = ord:getType()
						local ord_matched = false
						--match type
						if removing_order_string == "ai-waypoints-once" and ord_typ == ORDER_WAYPOINTS_ONCE then
							--waypoint needs to ensure that waypoint path name matches
							local ord_target = ord.Target
							if ord_target ~= nil and ord_target:isValid() and ord_target:getBreedName() == "Waypoint" then
								local ord_target_wp_list = ord_target:getList()
								if ord_target_wp_list ~= nil and ord_target_wp_list:isValid() and ord_target_wp_list.Name == target_of_removing_order_string then
									ord_matched = true
								end
							end
						elseif removing_order_string == "ai-play-dead-persistent" and ord_typ == ORDER_PLAY_DEAD_PERSISTENT then
							ord_matched = true
						end
						if ord_matched then
							matching_order_i = i
							break
						end
					end
				end
			end

		end

		return matching_order_i

	end

	function Movements:RemoveGoalCorrectly(ship, removing_order_priority, removing_order_string, target_of_removing_order_string) --currently supported are "ai-play-dead-persistent" and "ai-waypoints-once"

		local matching_order_i = self:GetMatchingOrder_i(ship, removing_order_priority, removing_order_string, target_of_removing_order_string)

		--remove
		if matching_order_i ~= nil then
			ship.Orders[matching_order_i]:remove()
			--ba.print("Movements: Removing order <"..removing_order_string.."> for ship "..ship.Name.." with priority "..tostring(removing_order_priority).."...\n")
		end

	end

	function Movements:GenericSubsystem_HitsPercent(ship, subsystem_basename)

		if ship ~= nil and ship:isValid() then
			--uses submodel name
			--also, does not respect "no-aggregate" flag!
			local numsubsystems = #ship
			subsystem_basename = string.lower(subsystem_basename)
			local hp_generic_total = 0
			local hp_generic_left = 0

			for i=1,numsubsystems do

				--get ss and model name
				local subsystem = ship[i]
				local actual_sub_name_lc = string.lower(tostring(subsystem:getModelName()))
				--make both subsystem_basename and actual_name lower case
				--if name matches then add hitpoints left to total
				if string.find(actual_sub_name_lc, subsystem_basename) ~= nil then
					hp_generic_total = hp_generic_total + subsystem.HitpointsMax
					hp_generic_left = hp_generic_left + subsystem.HitpointsLeft
				end

			end

			if hp_generic_total > 0 then
				if hp_generic_left <= 0 then
					return 0 
				else
					return (hp_generic_left/hp_generic_total)*100
				end
			else
				--if ss total is 0, then it can never ber destroyed, so must be at full hp
				return 100
			end
		else
			return 0
		end

	end

	function Movements:RandomPoint_In_ShipSphere(ship)

		local ship_radius = ship.Radius
		local ship_pos = ship.Position

		--from Brian Tung https://math.stackexchange.com/questions/1585975/how-to-generate-random-points-on-a-sphere

		local u1, u2 = ba.rand32f(), ba.rand32f() --If called with no arguments, returns a random float from [0.0, 1.0]
		local pi = math.pi

		local latitude = math.asin( (2 * u1) - 1 )
		local longitude = 2 * pi * u2

		local x = math.cos(latitude) * math.cos(longitude) * ship_radius
		local y = math.cos(latitude) * math.sin(longitude) * ship_radius 
		local z = math.sin(latitude) * ship_radius

		return ba.createVector(x + ship_pos.x, y + ship_pos.y, z + ship_pos.z)
		--ba.print(" Movements_Test: radius of sphere point to target center is "..ship_pos:getDistance(sphere_point)..", and radius is "..ship_radius.."\n")

	end

	function Movements:RandomPoint_On_ShipHull(ship, buffer_distance, return_local_coordinates)

		--finds a point on a ship's hull 

		--get ship and check validity
		if ship == nil then return nil end
		if not ship:isValid() then return nil end

		--default arguments
		if return_local_coordinates == nil then
			return_local_coordinates = false
		end
		if type(buffer_distance) ~= "number" then
			buffer_distance = 0
		end

		local ship_pos = ship.Position


		--1) Get a random point on the surface of the target ship's bounding sphere 
		local sphere_point = Movements:RandomPoint_In_ShipSphere(ship)

		--2) Run checkRayCollision from that point on the bounding sphere to the ship's center to get global position of hull intersection

			local hull_point, collision_data = ship:checkRayCollision(sphere_point, ship_pos, return_local_coordinates)
			--vector, collision_info checkRayCollision(vector StartPoint, vector EndPoint, [boolean Local = false])
			--Checks the collisions between the polygons of the current object and a ray. Start and end vectors are in world coordinates
			--Returns: World collision point (local if boolean is set to true) and the specific collsision info, nil if no collisions

		--3) Use that distance and line to select a new point on the intersect line, which should be touching the outside of the hull

			--note does not work if ship has no geometry at it's origin point, like a donut ship

			--it is expected to hit the ship/itself
			if hull_point ~= nil and collision_data ~= nil and collision_data:isValid() then

				--face to target, so do that math
				local position_diff = ship_pos - sphere_point 
				local norm_diff = position_diff:getNormalized()
				local pbh = norm_diff:getOrientation()

				return hull_point + pbh:unrotateVector(ba.createVector(0, 0, buffer_distance))
			else
				return nil 
			end


	end

	function Movements:RandomPoint_In_ShipBBox(ship, return_local_coordinates)

		--finds a point within a ship's bounding box 

		--get ship and check validity
		if ship == nil then return nil end
		if not ship:isValid() then return nil end

		local base_model = ship.Class.Model

		if base_model == nil then return end
		if not base_model:isValid() then return end

		--default arguments
		if return_local_coordinates == nil then
			return_local_coordinates = false
		end

		--run calculations
		local box_min = base_model.BoundingBoxMin
		local box_max = base_model.BoundingBoxMax

		if box_min == nil or box_max == nil then return end

		local rand_pos = {0, 0, 0}
		for i=1,3 do
			rand_pos[i] = ba.rand32f(box_min[i], box_max[i])
		end

		local rand_vec = ba.createVector(rand_pos[1], rand_pos[2], rand_pos[3])

		--rotate to be with self ship rotation
		local rand_pos_to_ship = ship.Position + ship.Orientation:unrotateVector(rand_vec)

		--return values
		if return_local_coordinates then
			return rand_vec
		else
			return rand_pos_to_ship
		end

	end


	mn.LuaSEXPs["set-bank-constant"].Action = function(bank_constant, ...)

		if not Movements.is_enabled then return end
		if #arg <= 0 then return end
		if type(bank_constant) ~= "number" then return end

		if bank_constant < 0 then 
			bank_constant = 0
		end

		for _, value in ipairs(arg) do
			local ship = value[1]
			if ship ~= nil and ship:isValid() then
				ship.Physics.BankingConstant = Movements:Round(bank_constant/100, 2)
			end
		end

	end

	mn.LuaSEXPs["set-deceleration-time"].Action = function(deceleration_time, ...)

		if not Movements.is_enabled then return end
		if #arg <= 0 then return end
		if type(deceleration_time) ~= "number" then return end

		if deceleration_time < 0 then 
			deceleration_time = 0 
		end

		for _, value in ipairs(arg) do
			local ship = value[1]
			if ship ~= nil and ship:isValid() then
				ship.Physics.ForwardDecelerationTime = Movements:Round(deceleration_time/1000, 4)
			end
		end

	end

	mn.LuaSEXPs["get-waypoint-speed-cap"].Action = function(ship) --returns 0 if ship invalid

		local cap = 0
		if ship ~= nil and ship:isValid() then
			cap = ship.WaypointSpeedCap
		end

		return cap

	end

	mn.LuaSEXPs["set-pos-to-rand-pos-on-hull"].Action = function(object_to_set_oswpt, target_ship, buffer_distance) 

		--does not set if something invalid

		--validity checks
		if object_to_set_oswpt == nil then return end
		local object_to_set = object_to_set_oswpt:get()
		if object_to_set == nil then return end
		if not object_to_set:isValid() then return end

		--get random position on hull, returns nil if target invalid
		local random_pos = Movements:RandomPoint_On_ShipHull(target_ship, buffer_distance)

		--set object to that position
		if random_pos ~= nil and Movements.is_enabled then
			object_to_set.Position = random_pos
		end

	end

	mn.LuaSEXPs["set-pos-to-rand-pos-in-b-box"].Action = function(object_to_set_oswpt, target_ship)

		--does not set if something invalid

		--validity checks
		if object_to_set_oswpt == nil then return end
		local object_to_set = object_to_set_oswpt:get()
		if object_to_set == nil then return end
		if not object_to_set:isValid() then return end

		--get random position on hull, returns nil if target invalid
		local random_pos = Movements:RandomPoint_In_ShipBBox(target_ship)

		--set object to that position
		if random_pos ~= nil and Movements.is_enabled then
			object_to_set.Position = random_pos
		end

	end


	function Movements:Add_Rotation(shipname, final_pbh, time_delay, time_for_rotation, play_dead_PR, targetobject_name, override_pbh_to_face_target) --requires pbh table in radians with {p=,b=,h=}

		--validity checks
		if not self.is_enabled then return end
		if shipname == nil then return end
		local ship = mn.Ships[shipname]
		if ship == nil then return end
		if not ship:isValid() then return end

		--only continue if engines are not blown out
		if self:GenericSubsystem_HitsPercent(ship, "engine") <= 0 then
			return
		end

		if not self:PBHisValid(final_pbh) then
			ba.print("Movements SEXP Warning: Add_Rotation() provided with invalid final_pbh, not running rotation...\n")
			return 
		end


		--default value setting

		--set play dead order if needed, default is disabled
		--negative value turns off play dead order
		if type(play_dead_PR) ~= "number" then
			play_dead_PR = -1
		end

		--cap at 200 to avoid errors too, recall there is no floor
		if play_dead_PR > 200 then
			play_dead_PR = 200 
		end

		--set times and keep everything positive
		--all times in seconds from sexp		
		local current_time = mn.getMissionTime()
		if type(time_delay) ~= "number" then
			time_delay = 0
		end
		if time_delay < 0 then
			time_delay = 0
		end

		--negative number runs default value of tabled turn times
		if type(time_for_rotation) ~= "number" then
			time_for_rotation = -1
		end

		if override_pbh_to_face_target == nil then
			override_pbh_to_face_target = false
		end


		--set times, and double check default determined time for rotation
		local start_time = time_delay + current_time

		local end_time
		--if using default rotation time then we do not precisely know the end time, so just set to -1
		if time_for_rotation < 0 then
			end_time = -1
		else 
			end_time = start_time + time_for_rotation
		end


		--add the entry to the active tracker table
		local initial_pbh = {p=ship.Orientation.p, b=ship.Orientation.b, h=ship.Orientation.h}

		--normalize pbh values
		final_pbh = self:NormalizePBH(final_pbh)
		local final_pbh_updated = self:NormalizePBH(final_pbh, initial_pbh)

		--add entry using shipname as key and update total number variable
		local entry = {
			shipname = shipname, 
			initial_pbh = initial_pbh,
			final_pbh = final_pbh, --this is the base final pbh we never want to change
			final_pbh_updated = final_pbh_updated, --this adds the target's orientation and can change, is set when rotation starts
			start_time = start_time, 
			end_time = end_time,
			play_dead_PR = play_dead_PR,
			isrotating = false,
			final_pbh_target_name = targetobject_name,
			override_pbh_to_face_target = override_pbh_to_face_target
		}

		--remove any other active rotations for this ship
		self:Remove_Rotation(shipname)

		self.Active_Rotations_Sum = self.Active_Rotations_Sum + 1

		self.Active_Rotations[shipname] = entry

	end

	function Movements:Remove_Rotation(shipname_key)

		if not self.is_enabled then return end
		if shipname_key == nil then return end
		local entry = self.Active_Rotations[shipname_key]

		--remove any play dead orders, remove from table and update tracker totals
		if entry ~= nil then

			--remove play dead order if it was using one
			if entry.play_dead_PR >= 0 then 
				self:RemoveGoalCorrectly(mn.Ships[entry.shipname], entry.play_dead_PR, "ai-play-dead-persistent")
			end

			--ba.print("Movements: rotation for ship "..shipname_key.." is removed ...\n")

			--set to nil and update tracker variables
			self.Active_Rotations[shipname_key] = nil
			self.Active_Rotations_Sum = self.Active_Rotations_Sum - 1

		end

	end

	function Movements:Run_Rotation()

		local mtime = mn.getMissionTime()

		--goes through list and rotates each entry based on time
		for _, v in pairs(self.Active_Rotations) do

			--only check and run if start time has come
			if mtime >= v.start_time and v.shipname ~= nil then
				--note: using both forcestop and no chop doesn't improve final pbh matching any better

				local ship = mn.Ships[v.shipname]
				if ship ~= nil and ship:isValid() then

					--overall, we should start the rotation if it has not started or continue it if it has started
					--so check which method of rotation we are using (two cases), both are useful in different situations
						--1. using specifed rotation time (specified end_time)  
							--specified rotation time is precise and works on non-AI ships
						--2. using default ship AI turn time (end_time -1)
							--AI turn time looks more natural and accounts for physics better

					local percent_done
					local using_ai_rotation = v.end_time < 0

					if using_ai_rotation then
						--AI turn time
						if (not v.isrotating) or (v.isrotating and not self:Orientations_are_Equal(ship.Orientation, v.final_pbh_updated)) then
							percent_done = 0 --bit hacky, but that's okay b/c with ai version we only use it to check if rotation is done
							--really this value is just to check to see if we should keep rotating per frame or not
						else
							percent_done = 1.1
						end
					else
						--specified rotation time
						percent_done = (mtime - v.start_time) / (v.end_time - v.start_time)

						if percent_done < 0 then
							percent_done = 0
						end

					end

					if percent_done <= 1 then

						local continue_with_rotation = true

						--if ship rotation has not started then check and start it (runs once to setup)
						--this mitigates issues with delayed starts
						if not v.isrotating then

							--update initial orientation with ships current orientation
							local shipor = ship.Orientation
							v.initial_pbh = nil
							v.initial_pbh = ba.createOrientation(shipor.p, shipor.b, shipor.h)

							--if we specified a final target name then check which type of rotation (relative to target or face target)
							--function 'get final pbh' accounts for all that:
								--relative to target -> update final pbh relative to target ship's orientation:
									--for example, if final pbh was 0,0,180 and relative target is specified then 
									--get the target orientation and add on that relative 0,0,180 value 
									--to get the updated final global orientation
								--face target -> final global pbh is calculated to face target

							local pbh_updated = self:GetFinal_PBH(ship, v.final_pbh, v.final_pbh_target_name, v.override_pbh_to_face_target)
							--^ will return pbh if no target object set
							--^ will be nil if targetobject_name is set but not in mission

							--if set to simply point to the object then just get final pbh that points to that target 

							if pbh_updated ~= nil then
								--make sure to normalize to initial 
								pbh_updated = self:NormalizePBH(pbh_updated, {p=v.initial_pbh.p, b=v.initial_pbh.b, h=v.initial_pbh.h})

								--save whole orientation now, as full orientation to use in AI function if needed
								v.final_pbh_updated = nil
								v.final_pbh_updated = ba.createOrientation(pbh_updated.p, pbh_updated.b, pbh_updated.h)

								--run play dead if needed (ie not negative value)
								if v.play_dead_PR >= 0 then
									ship:giveOrder(ORDER_PLAY_DEAD_PERSISTENT, nil, nil, v.play_dead_PR/100)
								end

								--finally, set that the ship is rotating
								v.isrotating = true

							else
								--if the target object was set but is not in mission then we don't need to rotate and we can set to nil 
								continue_with_rotation = false
								self:Remove_Rotation(v.shipname)
							end

						--else --already rotating so continue rotating
						end

						if continue_with_rotation then
							if using_ai_rotation then
								ship:turnTowardsOrientation(v.final_pbh_updated)
							else
								ship.Orientation = v.initial_pbh:rotationalInterpolate(v.final_pbh_updated, percent_done)
							end
						end

					else --if more then percent done, then remove from list
						--set ship orientation to final (in theory that should already be done)
						--setting may cause a jerking motion if the off chance the preceeding rotation didn't work, 
						--so only do with precise, specified rotation
						if not using_ai_rotation then
							ship.Orientation = v.initial_pbh:rotationalInterpolate(v.final_pbh_updated, 1.0)
						end

						--set just for consistency, technically it gets removed in the next function anyway
						v.isrotating = false

						--remove and update total variable
						self:Remove_Rotation(v.shipname)
					end

				end

			end

		end

	end

	mn.LuaSEXPs["move-to-orientation"].Action = function(ship, final_p, final_b, final_h, time_start_delay, time_for_effect, play_dead_priority)

		if ship ~= nil and ship:isValid() then

			if not Movements:PBHisValid({p=final_p, b=final_b, h=final_h}) then 
				ba.print("Movements SEXP Warning: move-to-orientation sexp provided with invalid final_pbh, not running rotation...\n")
				return 
			end

			local final_pbh = {
				p=math.rad(final_p), 
				b=math.rad(final_b), 
				h=math.rad(final_h)
			}

			--add entry
			--number checks are completed in function below 
			Movements:Add_Rotation(ship.Name, final_pbh, time_start_delay, time_for_effect, play_dead_priority)
		end

	end

	mn.LuaSEXPs["move-to-face-object"].Action = function(ship_to_rotate, obj_to_face_oswpt, time_start_delay, time_for_effect, play_dead_priority)

		if ship_to_rotate ~= nil and ship_to_rotate:isValid() and obj_to_face_oswpt ~= nil then

			local obj_to_face_name = Movements:Get_name_from_Ship_or_Wpt_Obj(obj_to_face_oswpt:get())

			if obj_to_face_name ~= nil then
				--add entry
				--number checks are completed in function below 
				Movements:Add_Rotation(ship_to_rotate.Name, {p=0,b=0,h=0}, time_start_delay, time_for_effect, play_dead_priority, obj_to_face_name, true)
			end

		end

	end

	mn.LuaSEXPs["early-stop-move-to-orientation"].Action = function(ship)

		if ship ~= nil and ship:isValid() then
			Movements:Remove_Rotation(ship.Name)
		end

	end


	function Movements:Add_Wpt_trk_Object(waypointpath_name, objecttarget_name, waypoint_i, offset_xyz, track_interval, track_distance, userelative)

		--validity checks
		if not self.is_enabled then return end
		if waypointpath_name == nil or objecttarget_name == nil then return end

		if type(offset_xyz) == "table" then
			if #offset_xyz ~= 3 then
				offset_xyz = {0,0,0}
			end
		else
			offset_xyz = {0,0,0}
		end

		if type(track_interval) ~= "number" then
			track_interval = 1.0
		end
		if track_interval < 0 then
			track_interval = 0
		end

		if type(track_distance) ~= "number" then
			track_distance = 0
		end
		if track_distance < 0 then
			track_distance = 0
		end

		if type(waypoint_i) ~= "number" then
			waypoint_i = 1
		end

		if type(waypointpath_name) ~= "string" then return end
		if type(objecttarget_name) ~= "string" then return end

		--check if object is ship or waypoint
		local object = self:Get_Ship_or_Wpt_Obj_from_name(objecttarget_name)
		if object == nil then return end
		if not object:isValid() then return end

		local waypointpath = mn.WaypointLists[waypointpath_name]
		if waypointpath == nil then return end
		if not waypointpath:isValid() then return end

		local waypoint = waypointpath[waypoint_i]
		if waypoint == nil then return end
		if not waypoint:isValid() then return end
		local waypoint_name = self:WaypointName(waypointpath_name, waypoint_i)

		if type(userelative) ~= "boolean" then
			userelative = true
		end

		--add entry
		local entry = {
			waypoint_i = waypoint_i,
			waypointpath_name = waypointpath_name,
			objecttarget_name = objecttarget_name,
			offset_xyz = offset_xyz,
			track_interval = track_interval,
			time_last_check = mn.getMissionTime(),
			track_distance = track_distance, 
			userelative = userelative
		}

		--clear any previous entry
		self:Remove_Wpt_trk_Object(waypoint_name)

		self.Active_Wpts_trk_Objects[waypoint_name] = entry

		--set position if needed
		local dis_wp_to_object = waypoint.Position:getDistance(object.Position)
		if dis_wp_to_object > track_distance then
			self:Set_Pos_Relative_to_Object(waypoint_name, objecttarget_name, offset_xyz, userelative)
		end

		--update tracker variables
		self.Active_Wpts_trk_Objects_Sum = self.Active_Wpts_trk_Objects_Sum + 1

	end

	function Movements:Check_Wpt_trk_Object()

		if self.Active_Wpts_trk_Objects_Sum > 0 then
			local mtime = mn.getMissionTime()
			for k_waypointname, v in pairs(self.Active_Wpts_trk_Objects) do
				--only check if interval time has surpased
				if mtime > v.time_last_check + v.track_interval then
					v.time_last_check = mtime
					--validity checks
					local object = self:Get_Ship_or_Wpt_Obj_from_name(v.objecttarget_name)
					if object ~= nil and object:isValid() then
						local wppath = mn.WaypointLists[v.waypointpath_name]
						if wppath ~= nil and wppath:isValid() then
							local wpoint = wppath[v.waypoint_i]
							if wpoint ~= nil and wpoint:isValid() then
								--then only continue if target object has moved far enough
								local dis_wp_to_object = wpoint.Position:getDistance(object.Position)
								if dis_wp_to_object > v.track_distance then
									self:Set_Pos_Relative_to_Object(k_waypointname, v.objecttarget_name, v.offset_xyz, v.userelative)
								end
							end
						end
					end
				end
			end
		end

	end

	function Movements:Remove_Wpt_trk_Object(waypointname_key)

		if not self.is_enabled then return end
		if waypointname_key == nil then return end
		local entry = self.Active_Wpts_trk_Objects[waypointname_key]

		if entry ~= nil then
			self.Active_Wpts_trk_Objects[waypointname_key] = nil
			self.Active_Wpts_trk_Objects_Sum = self.Active_Wpts_trk_Objects_Sum - 1
		end

	end

	mn.LuaSEXPs["add-waypoint-track-ship"].Action = function(target_object_owspt, waypointpath, waypoint_i, offset_x, offset_y, offset_z, track_interval, track_distance, userelative)

		if waypointpath == nil or target_object_owspt == nil then return end
		if not waypointpath:isValid() then return end

		if type(offset_x) ~= "number" then
			offset_x = 0
		end
		if type(offset_y) ~= "number" then
			offset_y = 0
		end
		if type(offset_z) ~= "number" then
			offset_z = 0
		end

		track_interval = track_interval or 0
		if type(track_interval) ~= "number" then return end
		--function below takes this value in seconds not milliseconds
		track_interval = track_interval/1000

		local xyz_tbl = {offset_x, offset_y, offset_z}

		local obj_to_track_name = Movements:Get_name_from_Ship_or_Wpt_Obj(target_object_owspt:get())

		if obj_to_track_name ~= nil then
			Movements:Add_Wpt_trk_Object(waypointpath.Name, obj_to_track_name, waypoint_i, xyz_tbl, track_interval, track_distance, userelative)
		end

	end

	mn.LuaSEXPs["remove-waypoint-track-ship"].Action = function(waypointpath, waypoint_i)

		if waypointpath == nil then return end
		if not waypointpath:isValid() then return end

		if type(waypoint_i) ~= "number" then
			waypoint_i = 1
		end

		local waypoint = waypointpath[waypoint_i]
		if waypoint == nil then return end 
		if not waypoint:isValid() then return end

		local waypoint_name = Movements:WaypointName(waypointpath.Name, waypoint_i)
		Movements:Remove_Wpt_trk_Object(waypoint_name)

	end


	function Movements:TimeUntilStop(shipname)

		local stoptime = 0
		--gets ships current forward velocity and calculates time it will take to reach 0 forward velocity with max declaration
		if shipname ~= nil then
			local ship = mn.Ships[shipname]
			if ship ~= nil and ship:isValid() then
				local sphysics = ship.Physics
				if sphysics ~= nil then

					local max_speed_z = math.max(sphysics.VelocityMax[3], 1)
					local current_speed_z = math.max(sphysics:getForwardSpeed(), 0)
					local decleration_time = math.max(sphysics.ForwardDecelerationTime, 1)

					local percent_speed = current_speed_z/max_speed_z
					if percent_speed > 1 then
						percent_speed = 1
					end

					--not systematic at all, but chose to go with X percent of deceleration time
					--fortunately the ship will rotate no matter what
					stoptime = math.ceil ( decleration_time * percent_speed )
				end
			end
		end

		return stoptime

	end

	function Movements:ObstacleInPath(ship, stop_ray_distance_min, ignore_ships_with_this_radius, time_check_interval, myship_radius, use_extra_safety_check) --assumes args are valid

		--failsafe validity checks, if either of these are -1 then we are not supposed to use smart stop
		if stop_ray_distance_min < 0 or ignore_ships_with_this_radius < 0 then
			return false, -1
		end

		local sphysics = ship.Physics
		if sphysics == nil then 
			return false, -1
		end

		if use_extra_safety_check == nil then
			use_extra_safety_check = true
		end

		--quick out if we are not even facing the waypoint?
		--if a ship blocks us, it woud be nice to rotate to at least face the waypoint?
		--possibly not, especially with less frequent interval checks
			--not facing waypoint, so start turning, 10 seconds later we could have already started moving and smashed into something 

		--get how fast ship is moving and time until next check
		--how far will ship have moved in that amount of time?
		local current_speed_z = sphysics:getForwardSpeed() --iswholenumber, onlypositive, abovezero all default to true
		if current_speed_z < 0 then
			current_speed_z = 0 
		end
		local decleration_time = sphysics.ForwardDecelerationTime

		local extra_slow_down_multiplier = math.max(decleration_time, 3) --minimum is bit of a magic number
		local distance_covered_by_next_check = time_check_interval * current_speed_z * extra_slow_down_multiplier -- ie 10 m/s * 1.5 seconds = 15 meters covered until next check
		--if that math.max(distance * 2, ship_radius*2) is > the closest obstacle then we better hit the brakes now
		local danger_zone_distance = math.max(stop_ray_distance_min * 1.2, distance_covered_by_next_check * 1.25) --bit more magic numbers

		--has line of sight only uses vectors, so make sure we ignore ourselves when doing obstacle checks
		--lets cast the ray from the center of the ship to ensure we see everything
		local ship_pos = ship.Position
		--the end of the ray cast should extend quite a bit along the forward vector of the ship
		local ray_end_pos = ship_pos + ship.Orientation:unrotateVector(ba.createVector(0, 0, danger_zone_distance*3))

		--boolean, number getLineOfSightFirstIntersect(vector from, vector to, [table excludedObjects (expects list of objects, empty by default), boolean testForShields = false, boolean testForHull = true, number threshold = 10.0])
		--Checks whether the to-position is in line of sight from the from-position and returns the distance to the first interruption of the line of sight, disregarding specific excluded objects and objects with a radius of less then threshold.
		--Returns: true and zero if there is line of sight, false and the distance otherwise.
		local has_line_of_sight, closest_obstacle_distance, intersecting_obj = mn.getLineOfSightFirstIntersect(ship_pos, ray_end_pos, {ship}, false, true, ignore_ships_with_this_radius)

		local obstacle_in_way = false
		--no for 'line of sight' means there is an obstacle somewhere, so we should check where
			--obstacle is witin danger zone -> obstacle in way = true
			--obstacle not witin danger zone -> obstacle in way = false
		--yes for 'line of sight' means no possibility for obstacles
		if not has_line_of_sight and intersecting_obj ~= nil and intersecting_obj:isValid() then

			--if there is an obstacle
			--account for ship and target self and any obstacle radius, if specified
			if use_extra_safety_check then
				local extra_safety_radius = myship_radius + self:GetRadius(tostring(intersecting_obj), true, 0)

				--update distance with safety radius and do check
				closest_obstacle_distance = closest_obstacle_distance - extra_safety_radius
			end

			if closest_obstacle_distance < 0 then 
				closest_obstacle_distance = 0 
			end

			if closest_obstacle_distance <= danger_zone_distance then
				obstacle_in_way = true
			--else --no obstacles in the way
			end
		--else --no obstacles in the way
		end

		return obstacle_in_way, intersecting_obj

	end

	function Movements:Add_Ship_trk_Wpt(shipname, waypoint_path_name, priority, track_interval, track_distance, input_final_pbh, final_pbh_target_name, continuous_pbh_check, play_dead_PR, uses_smart_stop, smart_stop_ray_distance_min, smart_stop_ignore_radius, use_extra_safety_check) --input_final_pbh should be {p=0,b=0,h=0} in radians

		--validity checks
		if not self.is_enabled then return end
		if shipname == nil then return end
		if not mn.Ships[shipname]:isValid() then return end
		if waypoint_path_name == nil then return end
		if mn.WaypointLists[waypoint_path_name] == nil then return end

		if type(continuous_pbh_check) ~= "boolean" then
			continuous_pbh_check = true
		end

		--priority checks
		if type(priority) ~= "number" then
			priority = 100
		end
		if priority < 0 then
			priority = 0
		end

		--set play_dead_PR priority, default is disabled
		--recall this one CAN be negative and if so it disables the play dead persistent
		if type(play_dead_PR) ~= "number" then
			play_dead_PR = -1
		end
		--cap if too high
		if play_dead_PR > 200 then
			play_dead_PR = 200
		end
		--no floor since it can be negative

		local mtime = mn.getMissionTime()

		--default for track time interval
		if type(track_interval) ~= "number" then
			track_interval = 1.500
		end
		if track_interval < 0 then
			track_interval = 0
		end

		local ship = mn.Ships[shipname]

		local waypoint_path = mn.WaypointLists[waypoint_path_name]

		if waypoint_path[1] == nil then return end

		if not waypoint_path[1]:isValid() then return end

		local num_waypoints = #waypoint_path --remember only good for one frame, so don't add extra waypoints to this path

		local last_wp = waypoint_path[num_waypoints]
		local first_wp = waypoint_path[1]
		if last_wp == nil or first_wp == nil then return end

		if not last_wp:isValid() or not first_wp:isValid() then return end

		--set known waypoint location (use this to counter act ship over-shooting waypoint)
		local previous_waypoint_location = last_wp.Position

		local ship_radius = self:GetRadius(shipname, true, 1)

		--set default track distance to ship radius
		--negative value also uses default value
		if type(track_distance) ~= "number" then
			track_distance = -1
		end
		if track_distance < 0 then
			track_distance = ship_radius
			--final safety check 
			if track_distance <= 0 then
				track_distance = 100
			end
		end

		--set final target pbh if available
		local final_pbh = {} --this is default, only change if the input had 3 number values
		if self:PBHisValid(input_final_pbh) then
			for _,v in ipairs({"p", "b", "h"}) do
				final_pbh[v] = input_final_pbh[v]
			end
		end

		--also set final target ship (will only work if final pbh set)
		if type(final_pbh_target_name) ~= "string" then
			final_pbh_target_name = nil
		end

		--check if the ship will try to stop if it is about to hit something
		--if using smart_stop then get radius of the ship *2 (-1 is default and disables this)
		--checks every track_interval
		if uses_smart_stop == nil then
			uses_smart_stop = false
		end

		if uses_smart_stop then
			--if obstacle is within this distance it will trigger a stop
			if type(smart_stop_ray_distance_min) ~= "number" then
				smart_stop_ray_distance_min = -1 -- -1 triggers default
			end
			if smart_stop_ray_distance_min < 0 then
				smart_stop_ray_distance_min = ship_radius * 2 --default value of ship diameter
			--else --keep as is
			end

			--any obstacles this radius or smaller will not be registered as obstacles
			if type(smart_stop_ignore_radius) ~= "number" then
				smart_stop_ignore_radius = -1 -- -1 triggers default
			end
			if smart_stop_ignore_radius < 0 then 
				smart_stop_ignore_radius = 25 --default value of 25
			end

			--use extra safety buffer, default is yes
			if use_extra_safety_check == nil then
				use_extra_safety_check = true
			end
		else
			smart_stop_ray_distance_min = -1
			smart_stop_ignore_radius = -1
			use_extra_safety_check = false
		end

		--add entry using shipname as key and update total number variable
		local entry = {
			shipname = shipname,
			waypoint_path_name = waypoint_path_name,
			num_waypoints = num_waypoints,
			priority = priority,
			play_dead_PR = play_dead_PR,
			track_interval = track_interval,
			time_last_check = mtime,
			previous_waypoint_location = previous_waypoint_location,
			track_distance = track_distance,
			is_running_waypoints_once = true,
			final_pbh = final_pbh, --remember needs to be in radians
			final_pbh_target_name = final_pbh_target_name,
			continuous_pbh_check = continuous_pbh_check,
			ship_radius = ship_radius,
			uses_smart_stop = uses_smart_stop,
			smart_stop_ray_distance_min = smart_stop_ray_distance_min, --only used if using smart stop
			smart_stop_triggered = false, --only used if using smart stop
			smart_stop_ignore_radius = smart_stop_ignore_radius, --only used if using smart stop,
			use_extra_safety_check = use_extra_safety_check
		}

		--remove any other tracking of waypoints for this ship
		self:Remove_Ship_trk_Wpt(shipname)

		--only give it the order if the ship is far enough away from the first waypoint
		--if the distance is not far enough away then it will keep checking on the ship track waypoint function
		--check to make sure there is not an obstacle in the path, too
		local dis_to_wp1 = first_wp.Position:getDistance(ship.Position)
		if dis_to_wp1 > track_distance then
			--if ship has space to actually run waypoints
			local run_order = true
			local obstacle_in_path, _ = self:ObstacleInPath(ship, entry.smart_stop_ray_distance_min, entry.smart_stop_ignore_radius, entry.track_interval, entry.ship_radius, entry.use_extra_safety_check)
			if uses_smart_stop and obstacle_in_path then
				run_order = false
				entry.smart_stop_triggered = true
				--if the obstacle ship is the target ship then the per simulation frame checks will take care of that
			end
			--give initial waypoint order if no obstacles
			if run_order then
				ship:giveOrder(ORDER_WAYPOINTS_ONCE, first_wp, nil, priority/100)
			end
		else -- if distance is too small then the ship is considered to have done its waypoint path instantly (On Waypoints Done)
			entry.is_running_waypoints_once = false
		end

		self.Active_Ships_trk_Wpts_Sum = self.Active_Ships_trk_Wpts_Sum + 1

		self.Active_Ships_trk_Wpts[shipname] = entry

	end

	function Movements:Remove_Ship_trk_Wpt(shipname_key)

		if not self.is_enabled then return end
		if shipname_key == nil then return end
		local entry = self.Active_Ships_trk_Wpts[shipname_key]

		if entry ~= nil then

			local ship = mn.Ships[entry.shipname]
			--remove any play dead order just in case they did not get removed when rotation done
			if entry.play_dead_PR >= 0 then 
				self:RemoveGoalCorrectly(ship, entry.play_dead_PR, "ai-play-dead-persistent")
			end

			--remove any waypoints once order
			self:RemoveGoalCorrectly(ship, entry.priority, "ai-waypoints-once", entry.waypoint_path_name)

			--remove from list and update variables
			self.Active_Ships_trk_Wpts[shipname_key] = nil
			self.Active_Ships_trk_Wpts_Sum = self.Active_Ships_trk_Wpts_Sum - 1

		end

	end

	function Movements:Pause_Ship_trk_Wpt(shipname, done_wp_path_name) --has to be only called with 'On Waypoints Done'

		--change waypoint status and save location of last waypoint

		--validity checks
		if not self.is_enabled then return end
		if shipname == nil or done_wp_path_name == nil then return end 
		local entry = self.Active_Ships_trk_Wpts[shipname]
		if entry == nil then return end

		--only continue if the completed waypoint was the one specified in tracker goal
		if entry.waypoint_path_name ~= done_wp_path_name then return end

		--change status, this (On Waypoints Done) is the only time this gets set to false (besides special instant waypoint finish on initiation)
		entry.is_running_waypoints_once = false

		--save last known waypoint location
		--using last known location of last waypoint helps mitigate effects of the ship over-shooting the final waypoint
		if entry.previous_waypoint_location ~= nil and entry.waypoint_path_name ~= nil then
			local wppath = mn.WaypointLists[entry.waypoint_path_name]
			if wppath ~= nil and wppath:isValid() and entry.num_waypoints ~= nil then
				local lastwp = wppath[entry.num_waypoints]
				if lastwp ~= nil and lastwp:isValid() and entry.previous_waypoint_location ~= nil then
					entry.previous_waypoint_location = lastwp.Position
				end
			end
		end

		--if there is a target orientation and no active rotations then add a run rotation order
			--recall that continuous checking of target pbh is done in ':Check_Ship_trk_Wpt()'
		if self:PBHisValid(entry.final_pbh) and self.Active_Rotations[shipname] == nil then

			--recall the ship just finished a waypoint..
			--need time delay so the craft is not moving forward anymore
			--calculate how long until it stops
			local rotate_delay = self:TimeUntilStop(shipname)
			local rotate_time = -1 --for default rotate time

			--add rotation
			self:Add_Rotation(shipname, entry.final_pbh, rotate_delay, rotate_time, entry.play_dead_PR, entry.final_pbh_target_name)

		--if not valid final orientation then don't run rotate-to-orientation
		end

	end

	function Movements:Obstacle_Is_FinalTarget(final_target_name, current_obstacle_obj)

		local answer = false

		if final_target_name ~= "" and final_target_name ~= nil then
			local final_target = mn.Ships[final_target_name]
			if final_target ~= nil and final_target:isValid() and current_obstacle_obj ~= nil and current_obstacle_obj:isValid() then
				--does final target == current obstacle?
				if current_obstacle_obj:getSignature() == final_target:getSignature() then
					answer = true
				end
			end
		end

		return answer

	end

	function Movements:Check_Ship_trk_Wpt() --checked every simulation frame

		if self.Active_Ships_trk_Wpts_Sum > 0 then
			local mtime = mn.getMissionTime()

			for _, v in pairs(self.Active_Ships_trk_Wpts) do

				--only check if the tracker time has elapsed
				if mtime > v.time_last_check + v.track_interval then

					v.time_last_check = mtime

					--check if ship is currently following waypoint order or not
						--if following then check if we need to do smart stop
						--if just chillin then check what ship needs to do now
					if v.is_running_waypoints_once then
						--does this ship use smart stop, if so then check if it needs to stop or if it needs to keep moving
						if v.uses_smart_stop then
							--validity checks
							local wpname = v.waypoint_path_name or ""
							local wppath = mn.WaypointLists[wpname]
							local ship = mn.Ships[v.shipname]
							if wppath ~= nil and wppath:isValid() and ship ~= nil and ship:isValid() then
								--more validity checks before get line of sight results
								local lastwp = wppath[v.num_waypoints]
								if lastwp ~= nil and lastwp:isValid() then 

									--cases
									--yes obstacle found
										--ship currently moving -> stop
										--ship not moving -> do nothing
									--no obstacles found
										--ship currently moving -> do nothing
										--ship not moving -> go and start moving again

									local ship_currently_moving = not v.smart_stop_triggered
									local obstacle_in_path, intersecting_obj = self:ObstacleInPath(ship, v.smart_stop_ray_distance_min, v.smart_stop_ignore_radius, v.track_interval, v.ship_radius, v.use_extra_safety_check)

									if obstacle_in_path then  --found obstacle
										if ship_currently_moving then
											--stop ship
											self:RemoveGoalCorrectly(ship, v.priority, "ai-waypoints-once", v.waypoint_path_name)
											v.smart_stop_triggered = true
										else --ship not moving
											--what if the ship stopped b/c it got too close to it's final target? (ie final target is the obstacle)
											--if that happens then this ship will never rotate to match target b/c it will never complete its waypoints
											--so, if the ship has been told to stop moving, then check if it's within distance to its target, then fake a waypoints complete
											local obstacle_is_target = false

											--if the ship is already within the wiggle room for a waypoint track then go ahead as a shortcut
											local dis_wp = lastwp.Position:getDistance(ship.Position)
											if dis_wp <= v.track_distance then

												obstacle_is_target = true

											else --shortcut didn't work so check if obstacle is target ship

												obstacle_is_target = self:Obstacle_Is_FinalTarget(v.final_pbh_target_name, intersecting_obj)

											end

											--if close enough to final waypoint or obstacle is target then consider "On Waypoints Done"
											if obstacle_is_target then
												self:Pause_Ship_trk_Wpt(v.shipname, v.waypoint_path_name)
											end

										end

									else --no obstacles
										if not ship_currently_moving then
											--start moving again
											local wp_list = mn.WaypointLists[v.waypoint_path_name]
											if wp_list ~= nil and wp_list:isValid() then
												ship:giveOrder(ORDER_WAYPOINTS_ONCE, wp_list[1], nil, v.priority/100)
											end
											v.smart_stop_triggered = false
										--else --ship is moving, and no obstacles so keep on doing what we are already doing
										end
									end

								end
							end
						--else --keep doing what we are already doing (following waypoints)
						end

					else --not running waypoint order (waypoints have been completed, waiting to see if need to update)

						--cases 
							--waypoint has moved far enough away to trigger refreshed path order
								--using smart stop and there is an obstacle
									--obstacle is target ship
										-->do not give refreshed order yet and do run about idle rotations
									--obstacle is not target ship 
										-->do not give refreshed order yet also do not worry about idle rotations
								--using smart stop and no obstacle or just not using smart stop
							--waypoint still within wiggle room for no new order
								--using smart stop and there is an obstacle
									--> does not matter, just rotating, and waypoints have already been completed so run idle rotation
								--using smart stop and no obstacle or just not using smart stop
									--> does not matter, just rotating, and waypoints have already been completed so run idle rotation

						local wpname = v.waypoint_path_name or ""
						local wppath = mn.WaypointLists[wpname]
						local ship = mn.Ships[v.shipname]

						--validity checks
						if wppath ~= nil and wppath:isValid() and ship ~= nil and ship:isValid() then

							local lastwp = wppath[v.num_waypoints]
							if lastwp ~= nil and lastwp:isValid() then

								--get distance between waypoint's last location and it's current new location (it might have moved)
								local dis_wp_previous_to_wp_now = lastwp.Position:getDistance(v.previous_waypoint_location)

								--see if distance between last waypoint path and ship is too far
									--using last known location of last waypoint helps mitigate effects of the ship overshootinng the final waypoint
									--add goal and set to tracking

								local check_run_pbh = false

								if dis_wp_previous_to_wp_now > v.track_distance then

									--if waypoint has moved too far then we need to stop what we are doing and follow it
									--recall the parent conditionals check if the waypoints order is already running

									--might have case where waypoint is far enough away to trigger new path order, but obstacle is the target ship
									local obstacle_in_path, intersecting_obj = self:ObstacleInPath(ship, v.smart_stop_ray_distance_min, v.smart_stop_ignore_radius, v.track_interval, v.ship_radius, v.use_extra_safety_check)
			
									if v.uses_smart_stop and obstacle_in_path then

										if self:Obstacle_Is_FinalTarget(v.final_pbh_target_name, intersecting_obj) then
											check_run_pbh = true
										end

									else --not using smart stop, or using smart stop and obstacle not in the way
										--run remove rotation just to be on the safe side
										self:Remove_Rotation(v.shipname)

										--start waypoints once
										local wp_list = mn.WaypointLists[v.waypoint_path_name]
										if wp_list ~= nil and wp_list:isValid() then
											ship:giveOrder(ORDER_WAYPOINTS_ONCE, wp_list[1], nil, v.priority/100)
										end
										v.is_running_waypoints_once = true
									end

								else

									check_run_pbh = true

								end

								if check_run_pbh then

									--if the ship does not have resume the waypoint order then
									--check if we are using the option to always match orientations
									--if so, then run the rotate order if the previous orientation is substantially different and not actively rotating
									--recall inital rotating to target pbh was already called when waypoint path was completed on :Pause_Ship_trk_Wpt()
									if v.continuous_pbh_check and self.Active_Rotations[v.shipname] == nil then

										--only using 'get final PBH' to check if current and final orientations are equal or not
										--recall that 'get final PBH' checks for validity 
										local fo = self:GetFinal_PBH(ship, v.final_pbh, v.final_pbh_target_name) --final_pbh in {p=,b=,h=}
										if not self:Orientations_are_Equal(ship.Orientation, fo, 0.02) then 

											--orientations are not equal, so add rotation order
											local rotate_time = -1 --for default rotate time
											local rotate_delay = 1
											self:Add_Rotation(v.shipname, v.final_pbh, rotate_delay, rotate_time, v.play_dead_PR, v.final_pbh_target_name)

										end

									end

								end

							end
						end
					end

				end

			end

		end

	end

	mn.LuaSEXPs["add-ai-goal-track-waypoint"].Action = function(ship, waypointpath, priority, track_interval, track_distance, use_smart_stop, smart_stop_ray_distance_min, smart_stop_ignore_radius, use_extra_safety_check)

		--recall this doesn't take into account target ship, so nothing about the orientation, continuous_pbh_check, or play_dead_PR is set here. 
		--this should only be used for waypoints not related to ships, if more is needed use the actual function

		if ship ~= nil and ship:isValid() then

			--add entry
			--number checks are completed in function below 
			--track_interval in sexp is in milliseconds so convert it to seconds 
			track_interval = track_interval or 1500
			if type(track_interval) ~= "number" then return end
			track_interval = track_interval/1000

			--function takes a waypoint_path_name as string but this sexp takes the entire waypoint_path object
			local waypointpath_name = waypointpath.Name

			--these defaults are set in following function
			--smart_stop_ray_distance_min, smart_stop_ignore_radius, use_extra_safety_check

			Movements:Add_Ship_trk_Wpt(ship.Name, waypointpath_name, priority, track_interval, track_distance, nil, nil, nil, nil, use_smart_stop, smart_stop_ray_distance_min, smart_stop_ignore_radius, use_extra_safety_check)
			--^^recall target is not used in this sexp, so it won't be used

		end

	end

	mn.LuaSEXPs["remove-ai-goal-track-waypoint"].Action = function(ship)

		if ship ~= nil and ship:isValid() then
			--number checks are completed in function below 
			Movements:Remove_Ship_trk_Wpt(ship.Name)
		end

	end


	function Movements:Set_Idle_Tracking_PBH(shipname, pitch, bank, heading, targetobject_name, continuous_pbh_check) --remember needs to be in radians

		--use this to update or set the idle orientation of a ship tracking a waypoint
		--remember needs to be in radians
		if not self.is_enabled then return end
		if shipname == nil then return end
		local entry = self.Active_Ships_trk_Wpts[shipname]
		if entry == nil then return end
		if type(continuous_pbh_check) ~= "boolean" then continuous_pbh_check = true end
		if type(pitch) == "number" and type(bank) == "number" and type(heading) == "number" then
			--update pbh
			local input_pbh = {p=pitch, b=bank, h=heading}
			for k,v in pairs(input_pbh) do
				entry.final_pbh[k] = v
			end

			--update continuous_pbh_check
			entry.continuous_pbh_check = continuous_pbh_check

			--update target object
			if type(targetobject_name) == "string" then
				entry.final_pbh_target_name = targetobject_name
			else
				entry.final_pbh_target_name = nil
			end
		end

	end

	function Movements:Unset_Idle_Tracking_PBH(shipname_key)

		--use this to remove the idle tracking function for a ship that is tracking a waypoint path
		if not self.is_enabled then return end
		if shipname_key == nil then return end
		if type(shipname_key) ~= "string" then return end
		local entry = self.Active_Ships_trk_Wpts[shipname_key]
		if entry == nil then return end

		entry.final_pbh = {}
		entry.final_pbh_target_name = nil
		entry.continuous_pbh_check = false

	end

	mn.LuaSEXPs["set-idle-track-orientation"].Action = function(ship, pitch, bank, heading, usetargetship, input_targetship, continuous_pbh_check)

		if ship ~= nil and ship:isValid() then
			--if target ship is specified only run if it's in mission
			if usetargetship == nil then
				usetargetship = false
			end
			local targetobject_name
			if usetargetship then --if false then it's nil
				if input_targetship == nil then return end
				if not input_targetship:isValid() then return end
				--^those function termination lines prevent set idle tracking from running with a nil target ship, because the target is not really supposed to be nil (it just hasn't arrived yet or is dod) 
				if input_targetship:isValid() then
					targetobject_name = input_targetship.Name
				end
			end

			if not Movements:PBHisValid({p=pitch, b=bank, h=heading}) then 
				ba.print("Movements SEXP Warning: set-idle-track-orientation sexp provided with invalid pitch, bank, or heading values, not setting orientation...\n")
				return 
			end

			Movements:Set_Idle_Tracking_PBH(ship.Name, math.rad(pitch), math.rad(bank), math.rad(heading), targetobject_name, continuous_pbh_check)
		end

	end

	mn.LuaSEXPs["unset-idle-track-orientation"].Action = function(ship)

		if ship ~= nil and ship:isValid() then
			Movements:Unset_Idle_Tracking_PBH(ship.Name)
		end

	end


	function Movements:GetRadius(shipname, donotround, forced_minimum) --gets radius of ship

		local final = 0

		if shipname ~= nil then
			local ship = mn.Ships[shipname]
			if ship ~= nil and ship:isValid() then
				local radius = ship.Radius
				if radius ~= nil then
					if donotround then
						final = radius
					else
						final = self:Round(radius)
					end
				end	
			end
		end

		return math.max(final, forced_minimum)

	end

	function Movements:Add_Ship_trk_Ship(ship_to_order_name, ship_to_track_name, waypointpath_name, waypoint_i, priority, offset, pbh, userelative, continuous_pbh_check, play_dead_PR, use_smart_stop) --pbh should be in radians
		--higher level function that runs all the above functions
		--recall this has access to some other arguments that the individual lower level sexps do not such as userelative, continuous_pbh_check, and play_dead_PR

		--set defaults 
		if not self.is_enabled then return end
		if type(ship_to_order_name) ~= "string" then return end
		if type(ship_to_track_name) ~= "string" then return end
		if type(waypointpath_name) ~= "string" then return end
		if type(waypoint_i) ~= "number" then
			waypoint_i = 1
		end
		if waypoint_i < 0 then
			waypoint_i = 1
		end
		local track_interval = 1.0 --default
		local track_distance = -1	---1 for radius default of ship radius

		local offset_xyz

		if type(offset) == "table" and type(offset[1]) == "number" and type(offset[2]) == "number" and type(offset[3]) == "number" then
			offset_xyz = offset
		else
			local default_offset = ( self:GetRadius(ship_to_order_name, true, 100) + self:GetRadius(ship_to_track_name, true, 100) ) * 1.5
			offset_xyz = {default_offset, default_offset, default_offset}
		end

		local idle_pbh = {} --if blank then does not rotate at end
		if self:PBHisValid(pbh) then
			for _,v in ipairs({"p", "b", "h"}) do
				idle_pbh[v] = pbh[v]
			end
		end

		--run waypoint track ship 
		self:Add_Wpt_trk_Object(waypointpath_name, ship_to_track_name, waypoint_i, offset_xyz, track_interval, track_distance, userelative)

		--run ship track waypoint, include setting 
		local track_distance_ship = -1 --so it uses default ship radius
		--other defaults and validity checks are performed in function below
		self:Add_Ship_trk_Wpt(ship_to_order_name, waypointpath_name, priority, track_interval, track_distance_ship, idle_pbh, ship_to_track_name, continuous_pbh_check, play_dead_PR, use_smart_stop)

	end

	function Movements:Remove_Ship_trk_Ship(shipname_to_remove_order, waypointpath_name, waypoint_i)

		--validity checks
		if not self.is_enabled then return end
		if type(shipname_to_remove_order) ~= "string" then return end
		if type(waypointpath_name) ~= "string" then return end
		if type(waypoint_i) ~= "number" then
			waypoint_i = 1
		end

		--first stop waypoint tracking ship
		local waypoint_name = self:WaypointName(waypointpath_name, waypoint_i)
		self:Remove_Wpt_trk_Object(waypoint_name)

		--then remove ship_order tracking of that waypoint 
		self:Remove_Ship_trk_Wpt(shipname_to_remove_order)

	end

	mn.LuaSEXPs["add-ai-goal-track-ship"].Action = function(ship_to_order, ship_to_track, waypointpath, priority, off_x, off_y, off_z, pbh_p, pbh_b, pbh_h, userelative, continuous_pbh_check, play_dead_PR, use_smart_stop)

		if ship_to_order == nil or ship_to_track == nil or waypointpath == nil then return end
		if not ship_to_order:isValid() or not ship_to_track:isValid() or not waypointpath:isValid() then return end

		local ship_to_order_name = ship_to_order.Name
		local ship_to_track_name = ship_to_track.Name
		local waypointpath_name = waypointpath.Name

		if type(pbh_p) ~= "number" then
			pbh_p = 0
		end
		if type(pbh_b) ~= "number" then
			pbh_b = 0
		end
		if type(pbh_h) ~= "number" then
			pbh_h = 0
		end

		pbh_p = math.rad(pbh_p)
		pbh_b = math.rad(pbh_b)
		pbh_h = math.rad(pbh_h)

		local waypoint_i = 1

		local offset = {off_x, off_y, off_z}
		local pbh = {p=pbh_p, b=pbh_b, h=pbh_h}

		Movements:Add_Ship_trk_Ship(ship_to_order_name, ship_to_track_name, waypointpath_name, waypoint_i, priority, offset, pbh, userelative, continuous_pbh_check, play_dead_PR, use_smart_stop)

	end

	mn.LuaSEXPs["remove-ai-goal-track-ship"].Action = function(ship_to_remove_order, waypointpath, waypoint_i)

		if ship_to_remove_order == nil or waypointpath == nil then return end
		if not ship_to_remove_order:isValid() or not waypointpath:isValid() then return end

		local ship_to_remove_order_name = ship_to_remove_order.Name
		--local ship_to_stop_track_name = ship_to_stop_track.Name
		local waypointpath_name = waypointpath.Name		

		Movements:Remove_Ship_trk_Ship(ship_to_remove_order_name, waypointpath_name, waypoint_i)

	end


	function Movements:Ship_DoD_Remove(shipname)

		--goes through all movements lists and removes entries of that ship where needed to save memory
		if type(shipname) ~= "string" then return end

		--stop any rotations
		self:Remove_Rotation(shipname)

		--go through waypoints track ship and search for this ship name 
		if self.Active_Wpts_trk_Objects_Sum > 0 then
			for k_waypointname, v in pairs(self.Active_Wpts_trk_Objects) do
				if v.objecttarget_name == shipname then
					self:Remove_Wpt_trk_Object(k_waypointname)
				end
			end
		end

		--remove any idle orientations that are using this ship has a relative orientation base
		if self.Active_Ships_trk_Wpts_Sum > 0 then
			for _, v in pairs(self.Active_Ships_trk_Wpts) do
				if v.final_pbh_target_name == shipname then
					v.final_pbh = {}
					v.final_pbh_target_name = nil
				end
			end
		end		

		--remove any ship tracking waypoints 
		self:Remove_Ship_trk_Wpt(shipname)

	end

	function Movements:OnSimulation()

		if self.is_enabled then
			local current_time = mn.getMissionTime()
			if current_time > 0.1 then
				--update rotations --now done on Simulation
				if self.Active_Rotations_Sum > 0 then
					self:Run_Rotation()
				end
				--update current time and check waypoints
				if current_time > self.Time_Previous_Check + self.G_Time_Check_Interval then
					self.Time_Previous_Check = current_time
					--check waypoints tracking ships
					if self.Active_Wpts_trk_Objects_Sum > 0 then
						self:Check_Wpt_trk_Object()
					end 
					--check ships tracking waypoints
					if self.Active_Ships_trk_Wpts_Sum > 0 then
						self:Check_Ship_trk_Wpt()
					end
				end
			end	
		end

	end

]


$State: GS_STATE_GAME_PLAY

$On Gameplay Start: [
	if Movements then
		Movements:Initiate()
	end
]

$On Waypoints Done: [
	local hs = hv.Ship
	local hswpp = hv.Waypointlist
	if Movements and Movements.is_enabled and hs ~= nil and hs:isValid() and hswpp ~= nil and hswpp:isValid() then
		Movements:Pause_Ship_trk_Wpt(hs.Name, hswpp.Name)
	end
]

$On Ship Death Started: [
	local hook_ship = hv.Ship
	if Movements and Movements.is_enabled and hook_ship ~= nil and hook_ship:isValid() then
		Movements:Ship_DoD_Remove(hook_ship.Name)
	end
]

$On Warp Out: [
	--also checking for warpout just because it triggers sooner
	--perfectly safe to remove many times because it only removes it if it is on the list
	local hook_ship = hv.Self
	if Movements and Movements.is_enabled and hook_ship ~= nil and hook_ship:isValid() then
		Movements:Ship_DoD_Remove(hook_ship.Name)
	end	
]

$On Ship Depart: [
	local hook_ship = hv.Ship
	if Movements and Movements.is_enabled and hook_ship ~= nil and hook_ship:isValid() then
		Movements:Ship_DoD_Remove(hook_ship.Name)
	end	
]

$On Goals Cleared: [
	local hook_ship = hv.Ship
	if Movements and Movements.is_enabled and hook_ship ~= nil and hook_ship:isValid() then
		local shipname = hook_ship.Name
		Movements:Remove_Rotation(shipname)
		Movements:Remove_Ship_trk_Wpt(shipname)
	end		
]

$On State End: [
	if Movements then
		Movements:Initiate()
	end
]


#End